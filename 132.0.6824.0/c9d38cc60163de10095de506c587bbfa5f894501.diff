diff --git a/content/public/renderer/pepper_plugin_instance.h b/content/public/renderer/pepper_plugin_instance.h
index fb9cb5e35d86b..6bf74d0e8f3b2 100644
--- a/content/public/renderer/pepper_plugin_instance.h
+++ b/content/public/renderer/pepper_plugin_instance.h
@@ -14,6 +14,7 @@
 #include "ppapi/c/pp_resource.h"
 #include "ppapi/c/pp_var.h"
 #include "ppapi/c/private/ppb_instance_private.h"
+#include "ppapi/c/private/ppb_pdf.h"
 #include "ui/base/ime/text_input_type.h"
 #include "ui/gfx/geometry/point_f.h"
 
@@ -108,6 +109,40 @@ class PepperPluginInstance {
 
   // Posts a message to the JavaScript object for this instance.
   virtual void PostMessageToJavaScript(PP_Var message) = 0;
+
+  // Sets the current mouse caret position.
+  virtual void SetCaretPosition(const gfx::PointF& position) = 0;
+
+  // Sends notification that the selection extent has been modified.
+  virtual void MoveRangeSelectionExtent(const gfx::PointF& extent) = 0;
+
+  // Sends notification of the base and extent of the current selection.
+  // The extent provided maybe modified by subsequent calls to
+  // MoveRangeSelectionExtent.
+  virtual void SetSelectionBounds(const gfx::PointF& base,
+                                  const gfx::PointF& extent) = 0;
+
+  // Returns true if the plugin text can be edited.
+  virtual bool CanEditText() = 0;
+
+  // Returns true if the plugin has editable text. i.e. The editable text field
+  // is non-empty. Assumes CanEditText() returns true.
+  virtual bool HasEditableText() = 0;
+
+  // Replaces the plugin's selected text, if any, with |text|. Assumes
+  // CanEditText() returns true.
+  virtual void ReplaceSelection(const std::string& text) = 0;
+
+  // Issues a select all command.
+  virtual void SelectAll() = 0;
+
+  // Returns true if the plugin can undo/redo.
+  virtual bool CanUndo() = 0;
+  virtual bool CanRedo() = 0;
+
+  // Issues undo and redo commands.
+  virtual void Undo() = 0;
+  virtual void Redo() = 0;
 };
 
 }  // namespace content
diff --git a/content/renderer/pepper/fake_pepper_plugin_instance.cc b/content/renderer/pepper/fake_pepper_plugin_instance.cc
index a2a83dc400506..9cf6e02671226 100644
--- a/content/renderer/pepper/fake_pepper_plugin_instance.cc
+++ b/content/renderer/pepper/fake_pepper_plugin_instance.cc
@@ -74,4 +74,36 @@ void FakePepperPluginInstance::SetLinkUnderCursor(const std::string& url) {}
 void FakePepperPluginInstance::SetTextInputType(ui::TextInputType type) {}
 void FakePepperPluginInstance::PostMessageToJavaScript(PP_Var message) {}
 
+void FakePepperPluginInstance::SetCaretPosition(const gfx::PointF& position) {}
+
+void FakePepperPluginInstance::MoveRangeSelectionExtent(
+    const gfx::PointF& extent) {}
+
+void FakePepperPluginInstance::SetSelectionBounds(const gfx::PointF& base,
+                                                  const gfx::PointF& extent) {}
+
+bool FakePepperPluginInstance::CanEditText() {
+  return false;
+}
+
+bool FakePepperPluginInstance::HasEditableText() {
+  return false;
+}
+
+void FakePepperPluginInstance::ReplaceSelection(const std::string& text) {}
+
+void FakePepperPluginInstance::SelectAll() {}
+
+bool FakePepperPluginInstance::CanUndo() {
+  return false;
+}
+
+bool FakePepperPluginInstance::CanRedo() {
+  return false;
+}
+
+void FakePepperPluginInstance::Undo() {}
+
+void FakePepperPluginInstance::Redo() {}
+
 }  // namespace content
diff --git a/content/renderer/pepper/fake_pepper_plugin_instance.h b/content/renderer/pepper/fake_pepper_plugin_instance.h
index 0ce68514912a6..fd1adeb26281b 100644
--- a/content/renderer/pepper/fake_pepper_plugin_instance.h
+++ b/content/renderer/pepper/fake_pepper_plugin_instance.h
@@ -41,6 +41,18 @@ class FakePepperPluginInstance : public PepperPluginInstance {
   void SetLinkUnderCursor(const std::string& url) override;
   void SetTextInputType(ui::TextInputType type) override;
   void PostMessageToJavaScript(PP_Var message) override;
+  void SetCaretPosition(const gfx::PointF& position) override;
+  void MoveRangeSelectionExtent(const gfx::PointF& extent) override;
+  void SetSelectionBounds(const gfx::PointF& base,
+                          const gfx::PointF& extent) override;
+  bool CanEditText() override;
+  bool HasEditableText() override;
+  void ReplaceSelection(const std::string& text) override;
+  void SelectAll() override;
+  bool CanUndo() override;
+  bool CanRedo() override;
+  void Undo() override;
+  void Redo() override;
 
  private:
   GURL gurl_;
diff --git a/content/renderer/pepper/pepper_plugin_instance_impl.cc b/content/renderer/pepper/pepper_plugin_instance_impl.cc
index 87bd9f2606e02..60b14653c234a 100644
--- a/content/renderer/pepper/pepper_plugin_instance_impl.cc
+++ b/content/renderer/pepper/pepper_plugin_instance_impl.cc
@@ -61,6 +61,7 @@
 #include "ppapi/c/ppp_messaging.h"
 #include "ppapi/c/ppp_mouse_lock.h"
 #include "ppapi/c/private/ppp_instance_private.h"
+#include "ppapi/c/private/ppp_pdf.h"
 #include "ppapi/host/ppapi_host.h"
 #include "ppapi/proxy/ppapi_messages.h"
 #include "ppapi/proxy/serialized_var.h"
@@ -103,6 +104,7 @@
 #include "third_party/blink/public/web/web_plugin_container.h"
 #include "third_party/blink/public/web/web_plugin_script_forbidden_scope.h"
 #include "third_party/blink/public/web/web_print_params.h"
+#include "third_party/blink/public/web/web_print_preset_options.h"
 #include "third_party/blink/public/web/web_script_source.h"
 #include "third_party/blink/public/web/web_view.h"
 #include "third_party/khronos/GLES2/gl2.h"
@@ -358,6 +360,13 @@ void PrintPDFOutput(PP_Resource print_output,
 #endif  // BUILDFLAG(ENABLE_PRINTING)
 }
 
+constexpr char kChromePrint[] = "chrome://print/";
+
+bool IsPrintPreviewUrl(const GURL& document_url) {
+  return url::Origin::Create(document_url.DeprecatedGetOriginAsURL()) ==
+         url::Origin::Create(GURL(kChromePrint));
+}
+
 // Stolen from //printing/units.{cc,h}
 
 // Length of an inch in CSS's 1pt unit.
@@ -482,9 +491,11 @@ PepperPluginInstanceImpl::PepperPluginInstanceImpl(
       find_identifier_(-1),
       plugin_input_event_interface_(nullptr),
       plugin_mouse_lock_interface_(nullptr),
+      plugin_pdf_interface_(nullptr),
       plugin_private_interface_(nullptr),
       plugin_textinput_interface_(nullptr),
       checked_for_plugin_input_event_interface_(false),
+      checked_for_plugin_pdf_interface_(false),
       metafile_(nullptr),
       gamepad_impl_(new GamepadImpl()),
       uma_private_impl_(nullptr),
@@ -1292,6 +1303,137 @@ std::u16string PepperPluginInstanceImpl::GetSelectedText(bool html) {
   return selected_text_;
 }
 
+std::u16string PepperPluginInstanceImpl::GetLinkAtPosition(
+    const gfx::Point& point) {
+  // Keep a reference on the stack. See NOTE above.
+  scoped_refptr<PepperPluginInstanceImpl> ref(this);
+  if (!LoadPdfInterface()) {
+    // TODO(koz): Change the containing function to GetLinkUnderCursor(). We can
+    // return |link_under_cursor_| here because this is only ever called with
+    // the current mouse coordinates.
+    return link_under_cursor_;
+  }
+
+  PP_Point p;
+  p.x = point.x();
+  p.y = point.y();
+  PP_Var rv = plugin_pdf_interface_->GetLinkAtPosition(pp_instance(), p);
+  // If the plugin returns undefined for this function it has switched to
+  // providing us with the link under the cursor eagerly.
+  if (rv.type == PP_VARTYPE_UNDEFINED)
+    return link_under_cursor_;
+  StringVar* string = StringVar::FromPPVar(rv);
+  std::u16string link;
+  if (string)
+    link = base::UTF8ToUTF16(string->value());
+  // Release the ref the plugin transfered to us.
+  PpapiGlobals::Get()->GetVarTracker()->ReleaseVar(rv);
+  return link;
+}
+
+void PepperPluginInstanceImpl::SetCaretPosition(const gfx::PointF& position) {
+  if (!LoadPdfInterface())
+    return;
+
+  PP_FloatPoint p;
+  p.x = position.x();
+  p.y = position.y();
+  plugin_pdf_interface_->SetCaretPosition(pp_instance(), &p);
+}
+
+void PepperPluginInstanceImpl::MoveRangeSelectionExtent(
+    const gfx::PointF& extent) {
+  if (!LoadPdfInterface())
+    return;
+
+  PP_FloatPoint p;
+  p.x = extent.x();
+  p.y = extent.y();
+  plugin_pdf_interface_->MoveRangeSelectionExtent(pp_instance(), &p);
+}
+
+void PepperPluginInstanceImpl::SetSelectionBounds(const gfx::PointF& base,
+                                                  const gfx::PointF& extent) {
+  if (!LoadPdfInterface())
+    return;
+
+  PP_FloatPoint p_base;
+  p_base.x = base.x();
+  p_base.y = base.y();
+
+  PP_FloatPoint p_extent;
+  p_extent.x = extent.x();
+  p_extent.y = extent.y();
+  plugin_pdf_interface_->SetSelectionBounds(pp_instance(), &p_base, &p_extent);
+}
+
+bool PepperPluginInstanceImpl::CanEditText() {
+  if (!LoadPdfInterface())
+    return false;
+  // No reference to |this| on the stack. Do not do any more work after this.
+  // See NOTE above.
+  return PP_ToBool(plugin_pdf_interface_->CanEditText(pp_instance()));
+}
+
+bool PepperPluginInstanceImpl::HasEditableText() {
+  if (!LoadPdfInterface())
+    return false;
+
+  // No reference to |this| on the stack. Do not do any more work after this.
+  // See NOTE above.
+  return PP_ToBool(plugin_pdf_interface_->HasEditableText(pp_instance()));
+}
+
+void PepperPluginInstanceImpl::ReplaceSelection(const std::string& text) {
+  if (!LoadPdfInterface())
+    return;
+
+  // No reference to |this| on the stack. Do not do any more work after this.
+  // See NOTE above.
+  plugin_pdf_interface_->ReplaceSelection(pp_instance(), text.c_str());
+}
+
+void PepperPluginInstanceImpl::SelectAll() {
+  if (!LoadPdfInterface())
+    return;
+
+  plugin_pdf_interface_->SelectAll(pp_instance());
+}
+
+bool PepperPluginInstanceImpl::CanUndo() {
+  if (!LoadPdfInterface())
+    return false;
+
+  // No reference to |this| on the stack. Do not do any more work after this.
+  // See NOTE above.
+  return PP_ToBool(plugin_pdf_interface_->CanUndo(pp_instance()));
+}
+
+bool PepperPluginInstanceImpl::CanRedo() {
+  if (!LoadPdfInterface())
+    return false;
+
+  // No reference to |this| on the stack. Do not do any more work after this.
+  // See NOTE above.
+  return PP_ToBool(plugin_pdf_interface_->CanRedo(pp_instance()));
+}
+
+void PepperPluginInstanceImpl::Undo() {
+  if (!LoadPdfInterface())
+    return;
+
+  // No reference to |this| on the stack. Do not do any more work after this.
+  // See NOTE above.
+  plugin_pdf_interface_->Undo(pp_instance());
+}
+
+void PepperPluginInstanceImpl::Redo() {
+  if (!LoadPdfInterface())
+    return;
+
+  plugin_pdf_interface_->Redo(pp_instance());
+}
+
 void PepperPluginInstanceImpl::RequestSurroundingText(
     size_t desired_number_of_characters) {
   // Keep a reference on the stack. See NOTE above.
@@ -1320,6 +1462,16 @@ bool PepperPluginInstanceImpl::LoadMouseLockInterface() {
   return !!plugin_mouse_lock_interface_;
 }
 
+bool PepperPluginInstanceImpl::LoadPdfInterface() {
+  if (!checked_for_plugin_pdf_interface_) {
+    checked_for_plugin_pdf_interface_ = true;
+    plugin_pdf_interface_ = static_cast<const PPP_Pdf*>(
+        module_->GetPluginInterface(PPP_PDF_INTERFACE_1));
+  }
+
+  return !!plugin_pdf_interface_;
+}
+
 bool PepperPluginInstanceImpl::LoadPrintInterface() {
   // Only check for the interface if the plugin has dev permission.
   if (!module_->permissions().HasPermission(ppapi::PERMISSION_DEV))
@@ -1580,6 +1732,7 @@ int PepperPluginInstanceImpl::PrintBegin(const WebPrintParams& print_params) {
                                                description.margin_top -
                                                description.margin_bottom));
 
+  int num_pages;
   PP_PrintSettings_Dev print_settings;
   print_settings.printable_area =
       CSSPixelsToPoints(print_params.printable_area_in_css_pixels);
@@ -1591,14 +1744,21 @@ int PepperPluginInstanceImpl::PrintBegin(const WebPrintParams& print_params) {
       static_cast<PP_PrintScalingOption_Dev>(print_params.print_scaling_option);
   print_settings.format = format;
 
-  // "fit to paper" should have never been a scaling option for the user to
-  // begin with, since it was only supported by the PDF plugin, which has been
-  // deleted.
-  DCHECK_NE(print_settings.print_scaling_option,
-            PP_PRINTSCALINGOPTION_FIT_TO_PAPER);
+  if (LoadPdfInterface()) {
+    PP_PdfPrintSettings_Dev pdf_print_settings;
+    pdf_print_settings.pages_per_sheet = print_params.pages_per_sheet;
+    pdf_print_settings.scale_factor = print_params.scale_factor;
+
+    num_pages = plugin_pdf_interface_->PrintBegin(
+        pp_instance(), &print_settings, &pdf_print_settings);
+  } else {
+    // If the content is not from the PDF plugin, "fit to paper" should have
+    // never been a scaling option for the user to begin with.
+    DCHECK_NE(print_settings.print_scaling_option,
+              PP_PRINTSCALINGOPTION_FIT_TO_PAPER);
 
-  int num_pages =
-      plugin_print_interface_->Begin(pp_instance(), &print_settings);
+    num_pages = plugin_print_interface_->Begin(pp_instance(), &print_settings);
+  }
   if (!num_pages)
     return 0;
 
@@ -1660,6 +1820,61 @@ void PepperPluginInstanceImpl::PrintEnd() {
   memset(&current_print_settings_, 0, sizeof(current_print_settings_));
 }
 
+bool PepperPluginInstanceImpl::GetPrintPresetOptionsFromDocument(
+    blink::WebPrintPresetOptions* preset_options) {
+  // Keep a reference on the stack. See NOTE above.
+  scoped_refptr<PepperPluginInstanceImpl> ref(this);
+  if (!LoadPdfInterface())
+    return false;
+
+  PP_PdfPrintPresetOptions_Dev options;
+  if (!plugin_pdf_interface_->GetPrintPresetOptionsFromDocument(pp_instance(),
+                                                                &options)) {
+    return false;
+  }
+
+  preset_options->is_scaling_disabled = PP_ToBool(options.is_scaling_disabled);
+  switch (options.duplex) {
+    case PP_PRIVATEDUPLEXMODE_SIMPLEX:
+      preset_options->duplex_mode = printing::mojom::DuplexMode::kSimplex;
+      break;
+    case PP_PRIVATEDUPLEXMODE_SHORT_EDGE:
+      preset_options->duplex_mode = printing::mojom::DuplexMode::kShortEdge;
+      break;
+    case PP_PRIVATEDUPLEXMODE_LONG_EDGE:
+      preset_options->duplex_mode = printing::mojom::DuplexMode::kLongEdge;
+      break;
+    default:
+      preset_options->duplex_mode =
+          printing::mojom::DuplexMode::kUnknownDuplexMode;
+      break;
+  }
+  preset_options->copies = options.copies;
+
+  if (options.is_page_size_uniform) {
+    preset_options->uniform_page_size = gfx::Size(
+        options.uniform_page_size.width, options.uniform_page_size.height);
+  }
+
+  return true;
+}
+
+bool PepperPluginInstanceImpl::CanRotateView() {
+  return LoadPdfInterface() && !module()->is_crashed() &&
+         !IsPrintPreviewUrl(document_url_);
+}
+
+void PepperPluginInstanceImpl::RotateView(WebPlugin::RotationType type) {
+  if (!LoadPdfInterface())
+    return;
+  PP_PrivatePageTransformType transform_type =
+      type == WebPlugin::RotationType::k90Clockwise
+          ? PP_PRIVATEPAGETRANSFORMTYPE_ROTATE_90_CW
+          : PP_PRIVATEPAGETRANSFORMTYPE_ROTATE_90_CCW;
+  plugin_pdf_interface_->Transform(pp_instance(), transform_type);
+  // NOTE: plugin instance may have been deleted.
+}
+
 bool PepperPluginInstanceImpl::IsFullscreenOrPending() {
   return desired_fullscreen_state_;
 }
@@ -1771,6 +1986,12 @@ void PepperPluginInstanceImpl::OnDestruct() {
   render_frame_ = nullptr;
 }
 
+bool PepperPluginInstanceImpl::SupportsKeyboardFocus() {
+  // Only PDF plugin supports keyboard focus. PDF plugin shouldn't be focusable
+  // if it's embedded in Print Preview.
+  return LoadPdfInterface() && !IsPrintPreviewUrl(document_url_);
+}
+
 void PepperPluginInstanceImpl::AddPluginObject(PluginObject* plugin_object) {
   DCHECK(!base::Contains(live_plugin_objects_, plugin_object));
   live_plugin_objects_.insert(plugin_object);
@@ -2365,6 +2586,8 @@ PP_ExternalPluginResult PepperPluginInstanceImpl::ResetAsProxied(
   plugin_input_event_interface_ = nullptr;
   checked_for_plugin_input_event_interface_ = false;
   plugin_mouse_lock_interface_ = nullptr;
+  plugin_pdf_interface_ = nullptr;
+  checked_for_plugin_pdf_interface_ = false;
   plugin_private_interface_ = nullptr;
   plugin_textinput_interface_ = nullptr;
 
diff --git a/content/renderer/pepper/pepper_plugin_instance_impl.h b/content/renderer/pepper/pepper_plugin_instance_impl.h
index 9a6bf18b53077..74f64a180fa4f 100644
--- a/content/renderer/pepper/pepper_plugin_instance_impl.h
+++ b/content/renderer/pepper/pepper_plugin_instance_impl.h
@@ -46,6 +46,7 @@
 #include "ppapi/c/ppp_input_event.h"
 #include "ppapi/c/ppp_mouse_lock.h"
 #include "ppapi/c/private/ppp_instance_private.h"
+#include "ppapi/c/private/ppp_pdf.h"
 #include "ppapi/shared_impl/ppb_instance_shared.h"
 #include "ppapi/shared_impl/ppb_view_shared.h"
 #include "ppapi/shared_impl/singleton_resource_id.h"
@@ -272,12 +273,18 @@ class CONTENT_EXPORT PepperPluginInstanceImpl
   void RemovePluginObject(PluginObject* plugin_object);
 
   std::u16string GetSelectedText(bool html);
+  std::u16string GetLinkAtPosition(const gfx::Point& point);
   void RequestSurroundingText(size_t desired_number_of_characters);
 
   bool SupportsPrintInterface();
   int PrintBegin(const blink::WebPrintParams& print_params);
   void PrintPage(int page_number, cc::PaintCanvas* canvas);
   void PrintEnd();
+  bool GetPrintPresetOptionsFromDocument(
+      blink::WebPrintPresetOptions* preset_options);
+
+  bool CanRotateView();
+  void RotateView(blink::WebPlugin::RotationType type);
 
   // Implementation of PPB_Fullscreen.
 
@@ -364,6 +371,18 @@ class CONTENT_EXPORT PepperPluginInstanceImpl
   void SetLinkUnderCursor(const std::string& url) override;
   void SetTextInputType(ui::TextInputType type) override;
   void PostMessageToJavaScript(PP_Var message) override;
+  void SetCaretPosition(const gfx::PointF& position) override;
+  void MoveRangeSelectionExtent(const gfx::PointF& extent) override;
+  void SetSelectionBounds(const gfx::PointF& base,
+                          const gfx::PointF& extent) override;
+  bool CanEditText() override;
+  bool HasEditableText() override;
+  void ReplaceSelection(const std::string& text) override;
+  void SelectAll() override;
+  bool CanUndo() override;
+  bool CanRedo() override;
+  void Undo() override;
+  void Redo() override;
 
   // PPB_Instance_API implementation.
   PP_Bool BindGraphics(PP_Instance instance, PP_Resource device) override;
@@ -451,6 +470,8 @@ class CONTENT_EXPORT PepperPluginInstanceImpl
     return *audio_controller_;
   }
 
+  bool SupportsKeyboardFocus();
+
  private:
   friend class base::RefCounted<PepperPluginInstanceImpl>;
   friend class PpapiPluginInstanceTest;
@@ -512,6 +533,7 @@ class CONTENT_EXPORT PepperPluginInstanceImpl
 
   bool LoadInputEventInterface();
   bool LoadMouseLockInterface();
+  bool LoadPdfInterface();
   bool LoadPrintInterface();
   bool LoadPrivateInterface();
   bool LoadTextInputInterface();
@@ -674,6 +696,7 @@ class CONTENT_EXPORT PepperPluginInstanceImpl
   // When adding PPP interfaces, make sure to reset them in ResetAsProxied.
   raw_ptr<const PPP_InputEvent> plugin_input_event_interface_;
   raw_ptr<const PPP_MouseLock> plugin_mouse_lock_interface_;
+  raw_ptr<const PPP_Pdf> plugin_pdf_interface_;
   raw_ptr<const PPP_Instance_Private> plugin_private_interface_;
   raw_ptr<const PPP_TextInput_Dev> plugin_textinput_interface_;
 
@@ -681,6 +704,7 @@ class CONTENT_EXPORT PepperPluginInstanceImpl
   // corresponding interfaces, so that we can ask only once.
   // When adding flags, make sure to reset them in ResetAsProxied.
   bool checked_for_plugin_input_event_interface_;
+  bool checked_for_plugin_pdf_interface_;
 
   // This is only valid between a successful PrintBegin call and a PrintEnd
   // call.
diff --git a/content/renderer/pepper/pepper_webplugin_impl.cc b/content/renderer/pepper/pepper_webplugin_impl.cc
index 109423ce34c17..940455c611bd6 100644
--- a/content/renderer/pepper/pepper_webplugin_impl.cc
+++ b/content/renderer/pepper/pepper_webplugin_impl.cc
@@ -36,6 +36,7 @@
 #include "third_party/blink/public/web/web_plugin_container.h"
 #include "third_party/blink/public/web/web_plugin_params.h"
 #include "third_party/blink/public/web/web_print_params.h"
+#include "third_party/blink/public/web/web_print_preset_options.h"
 #include "ui/base/cursor/cursor.h"
 #include "ui/events/keycodes/keyboard_codes.h"
 #include "url/gurl.h"
@@ -186,6 +187,10 @@ v8::Local<v8::Object> PepperWebPluginImpl::V8ScriptableObject(
   return result;
 }
 
+bool PepperWebPluginImpl::SupportsKeyboardFocus() const {
+  return instance_ && instance_->SupportsKeyboardFocus();
+}
+
 void PepperWebPluginImpl::Paint(cc::PaintCanvas* canvas,
                                 const gfx::Rect& rect) {
   // Re-entrancy may cause JS to try to execute script on the plugin before it
@@ -209,6 +214,30 @@ void PepperWebPluginImpl::UpdateFocus(bool focused,
   // is fully initialized. See: crbug.com/715747.
   if (instance_) {
     instance_->SetWebKitFocus(focused);
+
+    if (focused && instance_->SupportsKeyboardFocus()) {
+      switch (focus_type) {
+        case blink::mojom::FocusType::kForward:
+        case blink::mojom::FocusType::kBackward: {
+          int modifiers = blink::WebInputEvent::kNoModifiers;
+          if (focus_type == blink::mojom::FocusType::kBackward)
+            modifiers |= blink::WebInputEvent::kShiftKey;
+          // As part of focus management for plugin, blink brings plugin to
+          // focus but does not forward the tab event to plugin. Hence
+          // simulating tab event here to enable seamless tabbing across UI &
+          // plugin.
+          blink::WebKeyboardEvent simulated_event(
+              blink::WebInputEvent::Type::kKeyDown, modifiers,
+              base::TimeTicks());
+          simulated_event.windows_key_code = ui::KeyboardCode::VKEY_TAB;
+          ui::Cursor cursor;
+          instance_->HandleInputEvent(simulated_event, &cursor);
+          break;
+        }
+        default:
+          break;
+      }
+    }
   }
 }
 
@@ -289,6 +318,78 @@ WebString PepperWebPluginImpl::SelectionAsMarkup() const {
   return WebString::FromUTF16(instance_->GetSelectedText(true));
 }
 
+bool PepperWebPluginImpl::CanEditText() const {
+  return instance_ && instance_->CanEditText();
+}
+
+bool PepperWebPluginImpl::HasEditableText() const {
+  return instance_ && instance_->HasEditableText();
+}
+
+bool PepperWebPluginImpl::CanUndo() const {
+  return instance_ && instance_->CanUndo();
+}
+
+bool PepperWebPluginImpl::CanRedo() const {
+  return instance_ && instance_->CanRedo();
+}
+
+bool PepperWebPluginImpl::ExecuteEditCommand(const blink::WebString& name,
+                                             const blink::WebString& value) {
+  if (!instance_)
+    return false;
+
+  if (name == "Cut") {
+    if (!HasSelection() || !CanEditText())
+      return false;
+
+    instance_->ReplaceSelection("");
+    return true;
+  }
+
+  if (name == "Paste" || name == "PasteAndMatchStyle") {
+    if (!CanEditText())
+      return false;
+
+    instance_->ReplaceSelection(value.Utf8());
+    return true;
+  }
+
+  if (name == "SelectAll") {
+    if (!CanEditText())
+      return false;
+
+    instance_->SelectAll();
+    return true;
+  }
+
+  if (name == "Undo") {
+    if (!CanUndo())
+      return false;
+
+    instance_->Undo();
+    return true;
+  }
+
+  if (name == "Redo") {
+    if (!CanRedo())
+      return false;
+
+    instance_->Redo();
+    return true;
+  }
+
+  return false;
+}
+
+WebURL PepperWebPluginImpl::LinkAtPosition(const gfx::Point& position) const {
+  // Re-entrancy may cause JS to try to execute script on the plugin before it
+  // is fully initialized. See: crbug.com/715747.
+  if (!instance_)
+    return GURL();
+  return GURL(instance_->GetLinkAtPosition(position));
+}
+
 bool PepperWebPluginImpl::SupportsPaginatedPrint() {
   // Re-entrancy may cause JS to try to execute script on the plugin before it
   // is fully initialized. See: crbug.com/715747.
@@ -319,6 +420,30 @@ void PepperWebPluginImpl::PrintEnd() {
     instance_->PrintEnd();
 }
 
+bool PepperWebPluginImpl::GetPrintPresetOptionsFromDocument(
+    blink::WebPrintPresetOptions* preset_options) {
+  // Re-entrancy may cause JS to try to execute script on the plugin before it
+  // is fully initialized. See: crbug.com/715747.
+  if (!instance_)
+    return false;
+  return instance_->GetPrintPresetOptionsFromDocument(preset_options);
+}
+
+bool PepperWebPluginImpl::CanRotateView() {
+  // Re-entrancy may cause JS to try to execute script on the plugin before it
+  // is fully initialized. See: crbug.com/715747.
+  if (!instance_)
+    return false;
+  return instance_->CanRotateView();
+}
+
+void PepperWebPluginImpl::RotateView(blink::WebPlugin::RotationType type) {
+  // Re-entrancy may cause JS to try to execute script on the plugin before it
+  // is fully initialized. See: crbug.com/715747.
+  if (instance_)
+    instance_->RotateView(type);
+}
+
 void PepperWebPluginImpl::DidLoseMouseLock() {
   if (instance_)
     instance_->OnMouseLockLost();
diff --git a/content/renderer/pepper/pepper_webplugin_impl.h b/content/renderer/pepper/pepper_webplugin_impl.h
index e16ba5aab0a60..2c4c46f9de601 100644
--- a/content/renderer/pepper/pepper_webplugin_impl.h
+++ b/content/renderer/pepper/pepper_webplugin_impl.h
@@ -43,6 +43,7 @@ class PepperWebPluginImpl : public blink::WebPlugin {
   bool Initialize(blink::WebPluginContainer* container) override;
   void Destroy() override;
   v8::Local<v8::Object> V8ScriptableObject(v8::Isolate* isolate) override;
+  bool SupportsKeyboardFocus() const override;
   void UpdateAllLifecyclePhases(blink::DocumentUpdateReason) override {}
   void Paint(cc::PaintCanvas* canvas, const gfx::Rect& rect) override;
   void UpdateGeometry(const gfx::Rect& window_rect,
@@ -61,11 +62,22 @@ class PepperWebPluginImpl : public blink::WebPlugin {
   bool HasSelection() const override;
   blink::WebString SelectionAsText() const override;
   blink::WebString SelectionAsMarkup() const override;
+  bool CanEditText() const override;
+  bool HasEditableText() const override;
+  bool CanUndo() const override;
+  bool CanRedo() const override;
+  bool ExecuteEditCommand(const blink::WebString& name,
+                          const blink::WebString& value) override;
+  blink::WebURL LinkAtPosition(const gfx::Point& position) const override;
+  bool GetPrintPresetOptionsFromDocument(
+      blink::WebPrintPresetOptions* preset_options) override;
   bool SupportsPaginatedPrint() override;
 
   int PrintBegin(const blink::WebPrintParams& print_params) override;
   void PrintPage(int page_number, cc::PaintCanvas* canvas) override;
   void PrintEnd() override;
 
+  bool CanRotateView() override;
+  void RotateView(blink::WebPlugin::RotationType type) override;
   void DidLoseMouseLock() override;
   void DidReceiveMouseLockResult(bool success) override;
diff --git a/ppapi/c/private/ppp_pdf.h b/ppapi/c/private/ppp_pdf.h
index b45531f93bdc7..0e2c592939dc4 100644
--- a/ppapi/c/private/ppp_pdf.h
+++ b/ppapi/c/private/ppp_pdf.h
@@ -15,6 +15,14 @@
 #define PPP_PDF_INTERFACE_1 "PPP_Pdf;1"
 #define PPP_PDF_INTERFACE PPP_PDF_INTERFACE_1
 
+typedef enum {
+  // Rotates the page 90 degrees clockwise from its current orientation.
+  PP_PRIVATEPAGETRANSFORMTYPE_ROTATE_90_CW,
+  // Rotates the page 90 degrees counterclockwise from its current orientation.
+  PP_PRIVATEPAGETRANSFORMTYPE_ROTATE_90_CCW
+} PP_PrivatePageTransformType;
+PP_COMPILE_ASSERT_SIZE_IN_BYTES(PP_PrivatePageTransformType, 4);
+
 typedef enum {
   PP_PRIVATEDUPLEXMODE_NONE = 0,
   PP_PRIVATEDUPLEXMODE_SIMPLEX = 1,
@@ -53,6 +61,55 @@ struct PP_PdfPrintSettings_Dev {
 PP_COMPILE_ASSERT_STRUCT_SIZE_IN_BYTES(PP_PdfPrintSettings_Dev, 8);
 
 struct PPP_Pdf_1_1 {
+  // Returns an absolute URL if the position is over a link.
+  PP_Var (*GetLinkAtPosition)(PP_Instance instance,
+                              PP_Point point);
+
+  // Requests that the plugin apply the given transform to its view.
+  void (*Transform)(PP_Instance instance, PP_PrivatePageTransformType type);
+
+  // Return true if print preset options are updated from document.
+  PP_Bool (*GetPrintPresetOptionsFromDocument)(
+      PP_Instance instance,
+      PP_PdfPrintPresetOptions_Dev* options);
+
+  void (*SetCaretPosition)(PP_Instance instance,
+                           const struct PP_FloatPoint* position);
+  void (*MoveRangeSelectionExtent)(PP_Instance instance,
+                                   const struct PP_FloatPoint* extent);
+  void (*SetSelectionBounds)(PP_Instance instance,
+                             const struct PP_FloatPoint* base,
+                             const struct PP_FloatPoint* extent);
+
+  // Return true if plugin text can be edited. i.e. When focus is within an
+  // editable form text area (a form text field or user-editable form combobox
+  // text field.
+  PP_Bool (*CanEditText)(PP_Instance instance);
+
+  // Return true if plugin has editable text. i.e. When the focused editable
+  // field has content.
+  PP_Bool (*HasEditableText)(PP_Instance instance);
+
+  // Replace the plugin's selected text (if focus is in an editable text area).
+  // If there is no selected text, append the replacement text after the current
+  // caret position.
+  void (*ReplaceSelection)(PP_Instance instance, const char* text);
+
+  // Perform a select all operation.
+  void (*SelectAll)(PP_Instance instance);
+
+  // Return true if plugin can perform an undo operation.
+  PP_Bool (*CanUndo)(PP_Instance instance);
+
+  // Return true if plugin can perform a redo operation.
+  PP_Bool (*CanRedo)(PP_Instance instance);
+
+  // Perform an undo operation.
+  void (*Undo)(PP_Instance instance);
+
+  // Perform a redo operation.
+  void (*Redo)(PP_Instance instance);
+
   // This is a specialized version of PPP_Printing_Dev's Begin method.
   // It functions in the same way, but takes an additional |pdf_print_settings|
   // parameter. When the PPP_Pdf interface is available, use this instead of
diff --git a/ppapi/proxy/ppapi_messages.h b/ppapi/proxy/ppapi_messages.h
index 17655cbb82d99..843d43ad7b683 100644
--- a/ppapi/proxy/ppapi_messages.h
+++ b/ppapi/proxy/ppapi_messages.h
@@ -599,6 +599,42 @@ IPC_MESSAGE_ROUTED1(PpapiMsg_PPPMouseLock_MouseLockLost,
                     PP_Instance /* instance */)
 
 // PPP_Pdf
+IPC_MESSAGE_ROUTED2(PpapiMsg_PPPPdf_Rotate,
+                    PP_Instance /* instance */,
+                    bool /* clockwise */)
+IPC_SYNC_MESSAGE_ROUTED1_2(
+    PpapiMsg_PPPPdf_PrintPresetOptions,
+    PP_Instance /* instance */,
+    PP_PdfPrintPresetOptions_Dev /* print preset options */,
+    PP_Bool /* result */)
+IPC_MESSAGE_ROUTED2(PpapiMsg_PPPPdf_SetCaretPosition,
+                    PP_Instance /* instance */,
+                    PP_FloatPoint /* position */)
+IPC_MESSAGE_ROUTED2(PpapiMsg_PPPPdf_MoveRangeSelectionExtent,
+                    PP_Instance /* instance */,
+                    PP_FloatPoint /* extent */)
+IPC_MESSAGE_ROUTED3(PpapiMsg_PPPPdf_SetSelectionBounds,
+                    PP_Instance /* instance */,
+                    PP_FloatPoint /* base */,
+                    PP_FloatPoint /* extent */)
+IPC_SYNC_MESSAGE_ROUTED1_1(PpapiMsg_PPPPdf_CanEditText,
+                           PP_Instance /* instance */,
+                           PP_Bool /* result */)
+IPC_SYNC_MESSAGE_ROUTED1_1(PpapiMsg_PPPPdf_HasEditableText,
+                           PP_Instance /* instance */,
+                           PP_Bool /* result */)
+IPC_MESSAGE_ROUTED2(PpapiMsg_PPPPdf_ReplaceSelection,
+                    PP_Instance /* instance */,
+                    std::string /* text */)
+IPC_MESSAGE_ROUTED1(PpapiMsg_PPPPdf_SelectAll, PP_Instance /* instance */)
+IPC_SYNC_MESSAGE_ROUTED1_1(PpapiMsg_PPPPdf_CanUndo,
+                           PP_Instance /* instance */,
+                           PP_Bool /* result */)
+IPC_SYNC_MESSAGE_ROUTED1_1(PpapiMsg_PPPPdf_CanRedo,
+                           PP_Instance /* instance */,
+                           PP_Bool /* result */)
+IPC_MESSAGE_ROUTED1(PpapiMsg_PPPPdf_Undo, PP_Instance /* instance */)
+IPC_MESSAGE_ROUTED1(PpapiMsg_PPPPdf_Redo, PP_Instance /* instance */)
 IPC_SYNC_MESSAGE_ROUTED3_1(PpapiMsg_PPPPdf_PrintBegin,
                            PP_Instance /* instance */,
                            PP_PrintSettings_Dev /* print_settings */,
diff --git a/ppapi/proxy/ppp_pdf_proxy.cc b/ppapi/proxy/ppp_pdf_proxy.cc
index 58d3f48ebb0de..64984442bb248 100644
--- a/ppapi/proxy/ppp_pdf_proxy.cc
+++ b/ppapi/proxy/ppp_pdf_proxy.cc
@@ -15,6 +15,96 @@ namespace proxy {
 namespace {
 
 #if !BUILDFLAG(IS_NACL)
+PP_Var GetLinkAtPosition(PP_Instance instance, PP_Point point) {
+  // This isn't implemented in the out of process case.
+  return PP_MakeUndefined();
+}
+
+void Transform(PP_Instance instance, PP_PrivatePageTransformType type) {
+  bool clockwise = type == PP_PRIVATEPAGETRANSFORMTYPE_ROTATE_90_CW;
+  HostDispatcher::GetForInstance(instance)->Send(
+      new PpapiMsg_PPPPdf_Rotate(API_ID_PPP_PDF, instance, clockwise));
+}
+
+PP_Bool GetPrintPresetOptionsFromDocument(
+    PP_Instance instance,
+    PP_PdfPrintPresetOptions_Dev* options) {
+  PP_Bool ret = PP_FALSE;
+  HostDispatcher::GetForInstance(instance)
+      ->Send(new PpapiMsg_PPPPdf_PrintPresetOptions(
+          API_ID_PPP_PDF, instance, options, &ret));
+  return ret;
+}
+
+void SetCaretPosition(PP_Instance instance, const PP_FloatPoint* position) {
+  HostDispatcher::GetForInstance(instance)->Send(
+      new PpapiMsg_PPPPdf_SetCaretPosition(API_ID_PPP_PDF, instance,
+                                           *position));
+}
+
+void MoveRangeSelectionExtent(PP_Instance instance,
+                              const PP_FloatPoint* extent) {
+  HostDispatcher::GetForInstance(instance)->Send(
+      new PpapiMsg_PPPPdf_MoveRangeSelectionExtent(API_ID_PPP_PDF, instance,
+                                                   *extent));
+}
+
+void SetSelectionBounds(PP_Instance instance,
+                        const PP_FloatPoint* base,
+                        const PP_FloatPoint* extent) {
+  HostDispatcher::GetForInstance(instance)->Send(
+      new PpapiMsg_PPPPdf_SetSelectionBounds(API_ID_PPP_PDF, instance, *base,
+                                             *extent));
+}
+
+PP_Bool CanEditText(PP_Instance instance) {
+  PP_Bool ret = PP_FALSE;
+  HostDispatcher::GetForInstance(instance)->Send(
+      new PpapiMsg_PPPPdf_CanEditText(API_ID_PPP_PDF, instance, &ret));
+  return ret;
+}
+
+PP_Bool HasEditableText(PP_Instance instance) {
+  PP_Bool ret = PP_FALSE;
+  HostDispatcher::GetForInstance(instance)->Send(
+      new PpapiMsg_PPPPdf_HasEditableText(API_ID_PPP_PDF, instance, &ret));
+  return ret;
+}
+
+void ReplaceSelection(PP_Instance instance, const char* text) {
+  HostDispatcher::GetForInstance(instance)->Send(
+      new PpapiMsg_PPPPdf_ReplaceSelection(API_ID_PPP_PDF, instance, text));
+}
+
+void SelectAll(PP_Instance instance) {
+  HostDispatcher::GetForInstance(instance)->Send(
+      new PpapiMsg_PPPPdf_SelectAll(API_ID_PPP_PDF, instance));
+}
+
+PP_Bool CanUndo(PP_Instance instance) {
+  PP_Bool ret = PP_FALSE;
+  HostDispatcher::GetForInstance(instance)->Send(
+      new PpapiMsg_PPPPdf_CanUndo(API_ID_PPP_PDF, instance, &ret));
+  return ret;
+}
+
+PP_Bool CanRedo(PP_Instance instance) {
+  PP_Bool ret = PP_FALSE;
+  HostDispatcher::GetForInstance(instance)->Send(
+      new PpapiMsg_PPPPdf_CanRedo(API_ID_PPP_PDF, instance, &ret));
+  return ret;
+}
+
+void Undo(PP_Instance instance) {
+  HostDispatcher::GetForInstance(instance)->Send(
+      new PpapiMsg_PPPPdf_Undo(API_ID_PPP_PDF, instance));
+}
+
+void Redo(PP_Instance instance) {
+  HostDispatcher::GetForInstance(instance)->Send(
+      new PpapiMsg_PPPPdf_Redo(API_ID_PPP_PDF, instance));
+}
+
 int32_t PrintBegin(PP_Instance instance,
                    const PP_PrintSettings_Dev* print_settings,
                    const PP_PdfPrintSettings_Dev* pdf_print_settings) {
@@ -25,6 +115,20 @@ int32_t PrintBegin(PP_Instance instance,
 }
 
 const PPP_Pdf ppp_pdf_interface = {
+    &GetLinkAtPosition,
+    &Transform,
+    &GetPrintPresetOptionsFromDocument,
+    &SetCaretPosition,
+    &MoveRangeSelectionExtent,
+    &SetSelectionBounds,
+    &CanEditText,
+    &HasEditableText,
+    &ReplaceSelection,
+    &SelectAll,
+    &CanUndo,
+    &CanRedo,
+    &Undo,
+    &Redo,
     &PrintBegin,
 };
 #else
@@ -57,12 +161,112 @@ bool PPP_Pdf_Proxy::OnMessageReceived(const IPC::Message& msg) {
 
   bool handled = true;
   IPC_BEGIN_MESSAGE_MAP(PPP_Pdf_Proxy, msg)
+    IPC_MESSAGE_HANDLER(PpapiMsg_PPPPdf_Rotate, OnPluginMsgRotate)
+    IPC_MESSAGE_HANDLER(PpapiMsg_PPPPdf_PrintPresetOptions,
+                        OnPluginMsgPrintPresetOptions)
+    IPC_MESSAGE_HANDLER(PpapiMsg_PPPPdf_SetCaretPosition,
+                        OnPluginMsgSetCaretPosition)
+    IPC_MESSAGE_HANDLER(PpapiMsg_PPPPdf_MoveRangeSelectionExtent,
+                        OnPluginMsgMoveRangeSelectionExtent)
+    IPC_MESSAGE_HANDLER(PpapiMsg_PPPPdf_SetSelectionBounds,
+                        OnPluginMsgSetSelectionBounds)
+    IPC_MESSAGE_HANDLER(PpapiMsg_PPPPdf_CanEditText, OnPluginMsgCanEditText)
+    IPC_MESSAGE_HANDLER(PpapiMsg_PPPPdf_HasEditableText,
+                        OnPluginMsgHasEditableText)
+    IPC_MESSAGE_HANDLER(PpapiMsg_PPPPdf_ReplaceSelection,
+                        OnPluginMsgReplaceSelection)
+    IPC_MESSAGE_HANDLER(PpapiMsg_PPPPdf_SelectAll, OnPluginMsgSelectAll)
+    IPC_MESSAGE_HANDLER(PpapiMsg_PPPPdf_CanUndo, OnPluginMsgCanUndo)
+    IPC_MESSAGE_HANDLER(PpapiMsg_PPPPdf_CanRedo, OnPluginMsgCanRedo)
+    IPC_MESSAGE_HANDLER(PpapiMsg_PPPPdf_Undo, OnPluginMsgUndo)
+    IPC_MESSAGE_HANDLER(PpapiMsg_PPPPdf_Redo, OnPluginMsgRedo)
     IPC_MESSAGE_HANDLER(PpapiMsg_PPPPdf_PrintBegin, OnPluginMsgPrintBegin)
     IPC_MESSAGE_UNHANDLED(handled = false)
   IPC_END_MESSAGE_MAP()
   return handled;
 }
 
+void PPP_Pdf_Proxy::OnPluginMsgRotate(PP_Instance instance, bool clockwise) {
+  PP_PrivatePageTransformType type = clockwise ?
+      PP_PRIVATEPAGETRANSFORMTYPE_ROTATE_90_CW :
+      PP_PRIVATEPAGETRANSFORMTYPE_ROTATE_90_CCW;
+  if (ppp_pdf_)
+    CallWhileUnlocked(ppp_pdf_->Transform, instance, type);
+}
+
+void PPP_Pdf_Proxy::OnPluginMsgPrintPresetOptions(
+    PP_Instance instance,
+    PP_PdfPrintPresetOptions_Dev* options,
+    PP_Bool* result) {
+  if (ppp_pdf_) {
+    *result = CallWhileUnlocked(
+        ppp_pdf_->GetPrintPresetOptionsFromDocument, instance, options);
+  }
+}
+
+void PPP_Pdf_Proxy::OnPluginMsgSetCaretPosition(PP_Instance instance,
+                                                const PP_FloatPoint& position) {
+  if (ppp_pdf_)
+    CallWhileUnlocked(ppp_pdf_->SetCaretPosition, instance, &position);
+}
+
+void PPP_Pdf_Proxy::OnPluginMsgMoveRangeSelectionExtent(
+    PP_Instance instance,
+    const PP_FloatPoint& extent) {
+  if (ppp_pdf_)
+    CallWhileUnlocked(ppp_pdf_->MoveRangeSelectionExtent, instance, &extent);
+}
+
+void PPP_Pdf_Proxy::OnPluginMsgSetSelectionBounds(PP_Instance instance,
+                                                  const PP_FloatPoint& base,
+                                                  const PP_FloatPoint& extent) {
+  if (ppp_pdf_)
+    CallWhileUnlocked(ppp_pdf_->SetSelectionBounds, instance, &base, &extent);
+}
+
+void PPP_Pdf_Proxy::OnPluginMsgCanEditText(PP_Instance instance,
+                                           PP_Bool* result) {
+  *result = PP_FromBool(ppp_pdf_ &&
+                        CallWhileUnlocked(ppp_pdf_->CanEditText, instance));
+}
+
+void PPP_Pdf_Proxy::OnPluginMsgHasEditableText(PP_Instance instance,
+                                               PP_Bool* result) {
+  *result = PP_FromBool(ppp_pdf_ &&
+                        CallWhileUnlocked(ppp_pdf_->HasEditableText, instance));
+}
+
+void PPP_Pdf_Proxy::OnPluginMsgReplaceSelection(PP_Instance instance,
+                                                const std::string& text) {
+  if (ppp_pdf_)
+    CallWhileUnlocked(ppp_pdf_->ReplaceSelection, instance, text.c_str());
+}
+
+void PPP_Pdf_Proxy::OnPluginMsgSelectAll(PP_Instance instance) {
+  if (ppp_pdf_)
+    CallWhileUnlocked(ppp_pdf_->SelectAll, instance);
+}
+
+void PPP_Pdf_Proxy::OnPluginMsgCanUndo(PP_Instance instance, PP_Bool* result) {
+  *result =
+      PP_FromBool(ppp_pdf_ && CallWhileUnlocked(ppp_pdf_->CanUndo, instance));
+}
+
+void PPP_Pdf_Proxy::OnPluginMsgCanRedo(PP_Instance instance, PP_Bool* result) {
+  *result =
+      PP_FromBool(ppp_pdf_ && CallWhileUnlocked(ppp_pdf_->CanRedo, instance));
+}
+
+void PPP_Pdf_Proxy::OnPluginMsgUndo(PP_Instance instance) {
+  if (ppp_pdf_)
+    CallWhileUnlocked(ppp_pdf_->Undo, instance);
+}
+
+void PPP_Pdf_Proxy::OnPluginMsgRedo(PP_Instance instance) {
+  if (ppp_pdf_)
+    CallWhileUnlocked(ppp_pdf_->Redo, instance);
+}
+
 void PPP_Pdf_Proxy::OnPluginMsgPrintBegin(
     PP_Instance instance,
     const PP_PrintSettings_Dev& print_settings,
diff --git a/ppapi/proxy/ppp_pdf_proxy.h b/ppapi/proxy/ppp_pdf_proxy.h
index 9d034ae4862dc..417035821ff7d 100644
--- a/ppapi/proxy/ppp_pdf_proxy.h
+++ b/ppapi/proxy/ppp_pdf_proxy.h
@@ -5,6 +5,8 @@
 #ifndef PPAPI_PROXY_PPP_PDF_PROXY_H_
 #define PPAPI_PROXY_PPP_PDF_PROXY_H_
 
+#include <string>
+
 #include "ppapi/c/private/ppp_pdf.h"
 #include "ppapi/proxy/interface_proxy.h"
 
@@ -28,6 +30,26 @@ class PPP_Pdf_Proxy : public InterfaceProxy {
 
  private:
   // Message handlers.
+  void OnPluginMsgRotate(PP_Instance instance, bool clockwise);
+  void OnPluginMsgPrintPresetOptions(PP_Instance instance,
+                                     PP_PdfPrintPresetOptions_Dev* options,
+                                     PP_Bool* result);
+  void OnPluginMsgSetCaretPosition(PP_Instance instance,
+                                   const PP_FloatPoint& position);
+  void OnPluginMsgMoveRangeSelectionExtent(PP_Instance instance,
+                                           const PP_FloatPoint& extent);
+  void OnPluginMsgSetSelectionBounds(PP_Instance instance,
+                                     const PP_FloatPoint& base,
+                                     const PP_FloatPoint& extent);
+  void OnPluginMsgCanEditText(PP_Instance instance, PP_Bool* result);
+  void OnPluginMsgHasEditableText(PP_Instance instance, PP_Bool* result);
+  void OnPluginMsgReplaceSelection(PP_Instance instance,
+                                   const std::string& text);
+  void OnPluginMsgSelectAll(PP_Instance instance);
+  void OnPluginMsgCanUndo(PP_Instance instance, PP_Bool* result);
+  void OnPluginMsgCanRedo(PP_Instance instance, PP_Bool* result);
+  void OnPluginMsgUndo(PP_Instance instance);
+  void OnPluginMsgRedo(PP_Instance instance);
   void OnPluginMsgPrintBegin(PP_Instance instance,
                              const PP_PrintSettings_Dev& print_settings,
                              const PP_PdfPrintSettings_Dev& pdf_print_settings,

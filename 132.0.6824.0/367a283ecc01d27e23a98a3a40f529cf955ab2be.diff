diff --git a/content/public/renderer/pepper_plugin_instance.h b/content/public/renderer/pepper_plugin_instance.h
index 6bf74d0e8f3b2..2aa7c60001a3e 100644
--- a/content/public/renderer/pepper_plugin_instance.h
+++ b/content/public/renderer/pepper_plugin_instance.h
@@ -19,6 +19,7 @@
 #include "ui/gfx/geometry/point_f.h"
 
 class GURL;
+struct PP_PdfAccessibilityActionData;
 
 namespace base {
 class FilePath;
@@ -143,6 +144,10 @@ class PepperPluginInstance {
   // Issues undo and redo commands.
   virtual void Undo() = 0;
   virtual void Redo() = 0;
+
+  // Forwards Accessibility actions to plugin.
+  virtual void HandleAccessibilityAction(
+      const PP_PdfAccessibilityActionData& action_data) = 0;
 };
 
 }  // namespace content
diff --git a/content/renderer/pepper/fake_pepper_plugin_instance.cc b/content/renderer/pepper/fake_pepper_plugin_instance.cc
index 9cf6e02671226..ae3542dc0b320 100644
--- a/content/renderer/pepper/fake_pepper_plugin_instance.cc
+++ b/content/renderer/pepper/fake_pepper_plugin_instance.cc
@@ -106,4 +106,7 @@ void FakePepperPluginInstance::Undo() {}
 
 void FakePepperPluginInstance::Redo() {}
 
+void FakePepperPluginInstance::HandleAccessibilityAction(
+    const PP_PdfAccessibilityActionData& action_data) {}
+
 }  // namespace content
diff --git a/content/renderer/pepper/fake_pepper_plugin_instance.h b/content/renderer/pepper/fake_pepper_plugin_instance.h
index fd1adeb26281b..aa0d73761cda5 100644
--- a/content/renderer/pepper/fake_pepper_plugin_instance.h
+++ b/content/renderer/pepper/fake_pepper_plugin_instance.h
@@ -53,6 +53,8 @@ class FakePepperPluginInstance : public PepperPluginInstance {
   bool CanRedo() override;
   void Undo() override;
   void Redo() override;
+  void HandleAccessibilityAction(
+      const PP_PdfAccessibilityActionData& action_data) override;
 
  private:
   GURL gurl_;
diff --git a/content/renderer/pepper/pepper_plugin_instance_impl.cc b/content/renderer/pepper/pepper_plugin_instance_impl.cc
index 60b14653c234a..db62278fa179a 100644
--- a/content/renderer/pepper/pepper_plugin_instance_impl.cc
+++ b/content/renderer/pepper/pepper_plugin_instance_impl.cc
@@ -802,6 +802,9 @@ bool PepperPluginInstanceImpl::Initialize(
   if (success && !module_->renderer_ppapi_host()->IsExternalPluginHost())
     message_channel_->Start();
 
+  if (success)
+    HandleAccessibilityChange();
+
   initialized_ = success;
   return success;
 }
@@ -1434,6 +1437,14 @@ void PepperPluginInstanceImpl::Redo() {
   plugin_pdf_interface_->Redo(pp_instance());
 }
 
+void PepperPluginInstanceImpl::HandleAccessibilityAction(
+    const PP_PdfAccessibilityActionData& action_data) {
+  if (!LoadPdfInterface())
+    return;
+
+  plugin_pdf_interface_->HandleAccessibilityAction(pp_instance(), action_data);
+}
+
 void PepperPluginInstanceImpl::RequestSurroundingText(
     size_t desired_number_of_characters) {
   // Keep a reference on the stack. See NOTE above.
@@ -1982,6 +1993,11 @@ bool PepperPluginInstanceImpl::PrepareTransferableResource(
       bitmap_registrar, transferable_resource, release_callback);
 }
 
+void PepperPluginInstanceImpl::AccessibilityModeChanged(
+    const ui::AXMode& mode) {
+  HandleAccessibilityChange();
+}
+
 void PepperPluginInstanceImpl::OnDestruct() {
   render_frame_ = nullptr;
 }
@@ -2924,6 +2940,13 @@ bool PepperPluginInstanceImpl::IsTextureInUse(
                         &MailboxRefCount::first);
 }
 
+void PepperPluginInstanceImpl::HandleAccessibilityChange() {
+  if (render_frame_ && render_frame_->GetRenderAccessibility() &&
+      LoadPdfInterface()) {
+    plugin_pdf_interface_->EnableAccessibility(pp_instance());
+  }
+}
+
 void PepperPluginInstanceImpl::OnImeSetComposition(
     const std::u16string& text,
     const std::vector<ui::ImeTextSpan>& ime_text_spans,
diff --git a/content/renderer/pepper/pepper_plugin_instance_impl.h b/content/renderer/pepper/pepper_plugin_instance_impl.h
index 74f64a180fa4f..a9a2fe3a2551e 100644
--- a/content/renderer/pepper/pepper_plugin_instance_impl.h
+++ b/content/renderer/pepper/pepper_plugin_instance_impl.h
@@ -383,6 +383,8 @@ class CONTENT_EXPORT PepperPluginInstanceImpl
   bool CanRedo() override;
   void Undo() override;
   void Redo() override;
+  void HandleAccessibilityAction(
+      const PP_PdfAccessibilityActionData& action_data) override;
 
   // PPB_Instance_API implementation.
   PP_Bool BindGraphics(PP_Instance instance, PP_Resource device) override;
@@ -464,6 +466,7 @@ class CONTENT_EXPORT PepperPluginInstanceImpl
       viz::ReleaseCallback* release_callback) override;
 
   // RenderFrameObserver
+  void AccessibilityModeChanged(const ui::AXMode& mode) override;
   void OnDestruct() override;
 
   PepperAudioController& audio_controller() {
@@ -632,6 +635,8 @@ class CONTENT_EXPORT PepperPluginInstanceImpl
   // Whether a given viz::TransferableResource is in use by |texture_layer_|.
   bool IsTextureInUse(const viz::TransferableResource& resource) const;
 
+  void HandleAccessibilityChange();
+
   raw_ptr<RenderFrameImpl> render_frame_;
   scoped_refptr<PluginModule> module_;
   std::unique_ptr<ppapi::PPP_Instance_Combined> instance_interface_;
diff --git a/pdf/accessibility_structs.h b/pdf/accessibility_structs.h
index 2d275119c7655..58538f4b56065 100644
--- a/pdf/accessibility_structs.h
+++ b/pdf/accessibility_structs.h
@@ -32,6 +32,9 @@ struct AccessibilityPageInfo {
   bool is_searchified = false;
 };
 
+// TODO(crbug.com/1144444): Remove next line comment after PDF migrates away
+// from Pepper.
+// Explicitly set all enum values to match enum values in PP_TextRenderingMode.
 // See PDF Reference 1.7, page 402, table 5.3.
 enum class AccessibilityTextRenderMode {
   kUnknown = -1,
@@ -71,6 +74,9 @@ struct AccessibilityTextStyleInfo {
   bool is_bold = false;
 };
 
+// TODO(crbug.com/1144444): Remove next line comment after PDF migrates away
+// from Pepper.
+// Explicitly set all enum values to match enum values in PP_PrivateDirection.
 enum class AccessibilityTextDirection {
   kNone = 0,
   kLeftToRight = 1,
@@ -208,6 +214,10 @@ struct AccessibilityChoiceFieldOptionInfo {
   gfx::RectF bounds;
 };
 
+// TODO(crbug.com/702993): Remove next line comment after PDF migrates away
+// from Pepper.
+// Explicitly set all enum values to match enum values in
+// PP_PrivateChoiceFieldType.
 enum class ChoiceFieldType {
   kListBox = 0,
   kComboBox = 1,
@@ -253,6 +263,9 @@ struct AccessibilityChoiceFieldInfo {
   gfx::RectF bounds;
 };
 
+// TODO(crbug.com/702993): Remove next line comment after PDF migrates away
+// from Pepper.
+// Explicitly set all enum values to match enum values in PP_PrivateButtonType.
 enum class ButtonType {
   kPushButton = 1,
   kCheckBox = 2,
@@ -336,6 +349,10 @@ struct AccessibilityPageObjects {
   AccessibilityFormFieldInfo form_fields;
 };
 
+// TODO(crbug.com/702993): Remove next line comment after PDF migrates away
+// from Pepper.
+// Explicitly set all enum values to match enum values in
+// PP_PrivateFocusObjectType.
 enum class FocusObjectType {
   kNone = 0,
   kDocument = 1,
@@ -363,6 +380,10 @@ struct AccessibilityViewportInfo {
   AccessibilityFocusInfo focus_info;
 };
 
+// TODO(crbug.com/702993): Remove next line comment after PDF migrates away
+// from Pepper.
+// Explicitly set all enum values to match enum values in
+// PP_PdfAccessibilityAction.
 enum class AccessibilityAction {
   // No action specified.
   kNone = 0,
@@ -378,6 +399,10 @@ enum class AccessibilityAction {
   kMaxValue = kSetSelection,
 };
 
+// TODO(crbug.com/702993): Remove next line comment after PDF migrates away
+// from Pepper.
+// Explicitly set all enum values to match enum values in
+// PP_PdfAccessibilityAnnotationType.
 enum class AccessibilityAnnotationType {
   // No annotation type defined.
   kNone = 0,
diff --git a/ppapi/c/private/ppb_pdf.h b/ppapi/c/private/ppb_pdf.h
index 4199699476e58..b169a84c011fa 100644
--- a/ppapi/c/private/ppb_pdf.h
+++ b/ppapi/c/private/ppb_pdf.h
@@ -41,6 +41,349 @@ struct PP_PrivateFindResult {
   int length;
 };
 
+typedef enum {
+  PP_PRIVATEFOCUSOBJECT_NONE = 0,
+  PP_PRIVATEFOCUSOBJECT_DOCUMENT = 1,
+  PP_PRIVATEFOCUSOBJECT_LINK = 2,
+  PP_PRIVATEFOCUSOBJECT_HIGHLIGHT = 3,
+  PP_PRIVATEFOCUSOBJECT_TEXT_FIELD = 4,
+  PP_PRIVATEFOCUSOBJECT_LAST = PP_PRIVATEFOCUSOBJECT_TEXT_FIELD
+} PP_PrivateFocusObjectType;
+
+// Represents the information to uniquely identify the focused object
+// in PDF.
+struct PP_PrivateAccessibilityFocusInfo {
+  // Holds the type of the focused object in PDFiumEngine.
+  PP_PrivateFocusObjectType focused_object_type;
+  // Holds the PDF page index in the which the focused annotation is present.
+  // When |focused_object_type| is PP_PRIVATEFOCUSOBJECT_NONE or
+  // PP_PRIVATEFOCUSOBJECT_DOCUMENT then the value of this member shouldn't
+  // be used, set to zero as a sentinel value.
+  uint32_t focused_object_page_index;
+  // Holds the focused annotation's index in page's annotations array.
+  // When |focused_object_type| is PP_PRIVATEFOCUSOBJECT_NONE or
+  // PP_PRIVATEFOCUSOBJECT_DOCUMENT then the value of this member shouldn't
+  // be used, set to zero as a sentinel value.
+  uint32_t focused_annotation_index_in_page;
+};
+
+struct PP_PrivateAccessibilityViewportInfo {
+  double zoom;
+  double scale;
+  struct PP_Point scroll;
+  struct PP_Point offset;
+  uint32_t selection_start_page_index;
+  uint32_t selection_start_char_index;
+  uint32_t selection_end_page_index;
+  uint32_t selection_end_char_index;
+  struct PP_PrivateAccessibilityFocusInfo focus_info;
+};
+
+struct PP_PrivateAccessibilityDocInfo {
+  uint32_t page_count;
+  PP_Bool text_accessible;
+  PP_Bool text_copyable;
+};
+
+typedef enum {
+  PP_PRIVATEDIRECTION_NONE = 0,
+  PP_PRIVATEDIRECTION_LTR = 1,
+  PP_PRIVATEDIRECTION_RTL = 2,
+  PP_PRIVATEDIRECTION_TTB = 3,
+  PP_PRIVATEDIRECTION_BTT = 4,
+  PP_PRIVATEDIRECTION_LAST = PP_PRIVATEDIRECTION_BTT
+} PP_PrivateDirection;
+
+struct PP_PrivateAccessibilityPageInfo {
+  uint32_t page_index;
+  struct PP_Rect bounds;
+  uint32_t text_run_count;
+  uint32_t char_count;
+};
+
+// See PDF Reference 1.7, page 402, table 5.3.
+typedef enum {
+  PP_TEXTRENDERINGMODE_UNKNOWN = -1,
+  PP_TEXTRENDERINGMODE_FIRST = PP_TEXTRENDERINGMODE_UNKNOWN,
+  PP_TEXTRENDERINGMODE_FILL = 0,
+  PP_TEXTRENDERINGMODE_STROKE = 1,
+  PP_TEXTRENDERINGMODE_FILLSTROKE = 2,
+  PP_TEXTRENDERINGMODE_INVISIBLE = 3,
+  PP_TEXTRENDERINGMODE_FILLCLIP = 4,
+  PP_TEXTRENDERINGMODE_STROKECLIP = 5,
+  PP_TEXTRENDERINGMODE_FILLSTROKECLIP = 6,
+  PP_TEXTRENDERINGMODE_CLIP = 7,
+  PP_TEXTRENDERINGMODE_LAST = PP_TEXTRENDERINGMODE_CLIP
+} PP_TextRenderingMode;
+
+// This holds the text style information provided by the PDF and will be used
+// in accessibility to provide the text style information. Needs to stay in
+// sync with C++ version. (PrivateAccessibilityTextStyleInfo and
+// PdfAccessibilityTextStyleInfo)
+struct PP_PrivateAccessibilityTextStyleInfo {
+  const char* font_name;
+  uint32_t font_name_length;
+  int font_weight;
+  PP_TextRenderingMode render_mode;
+  float font_size;
+  // Colors are ARGB.
+  uint32_t fill_color;
+  uint32_t stroke_color;
+  bool is_italic;
+  bool is_bold;
+};
+
+// This holds the text run information provided by the PDF and will be used in
+// accessibility to provide the text run information.
+// Needs to stay in sync with C++ version. (PrivateAccessibilityTextRunInfo and
+// PdfAccessibilityTextRunInfo)
+struct PP_PrivateAccessibilityTextRunInfo {
+  uint32_t len;
+  struct PP_FloatRect bounds;
+  PP_PrivateDirection direction;
+  struct PP_PrivateAccessibilityTextStyleInfo style;
+};
+
+struct PP_PrivateAccessibilityCharInfo {
+  uint32_t unicode_character;
+  double char_width;
+};
+
+// This holds the link information provided by the PDF and will be used in
+// accessibility to provide the link information. Needs to stay in sync with
+// C++ versions (PdfAccessibilityLinkInfo and PrivateAccessibilityLinkInfo).
+// This struct contains index state that should be validated using
+// PdfAccessibilityTree::IsDataFromPluginValid() before usage.
+struct PP_PrivateAccessibilityLinkInfo {
+  // URL of the link.
+  const char* url;
+  uint32_t url_length;
+  // Index of the link in the page. This will be used to identify the link on
+  // which action has to be performed in the page.
+  // |index_in_page| is populated and used in plugin process to handle
+  // accessiility actions from mimehandler process. It's value should be
+  // validated in plugin before usage.
+  uint32_t index_in_page;
+  // Link can either be part of the page text or not. If the link is part of the
+  // page text, then |text_run_index| denotes the text run which contains the
+  // start_index of the link and the |text_run_count| equals the number of text
+  // runs the link spans in the page text. If the link is not part of the page
+  // text then |text_run_count| should be 0 and the |text_run_index| should
+  // contain the nearest char index to the bounding rectangle of the link.
+  uint32_t text_run_index;
+  uint32_t text_run_count;
+  // Bounding box of the link.
+  struct PP_FloatRect bounds;
+};
+
+// This holds the image information provided by the PDF and will be used in
+// accessibility to provide the image information. Needs to stay in sync with
+// C++ versions (PdfAccessibilityImageInfo and PrivateAccessibilityImageInfo).
+// This struct contains index state that should be validated using
+// PdfAccessibilityTree::IsDataFromPluginValid() before usage.
+struct PP_PrivateAccessibilityImageInfo {
+  // Alternate text for the image provided by PDF.
+  const char* alt_text;
+  uint32_t alt_text_length;
+  // We anchor the image to a char index, this denotes the text run before
+  // which the image should be inserted in the accessibility tree. The text run
+  // at this index should contain the anchor char index.
+  uint32_t text_run_index;
+  // Bounding box of the image.
+  struct PP_FloatRect bounds;
+};
+
+// This holds text highlight information provided by the PDF and will be
+// used in accessibility to expose it. Text highlights can have an associated
+// popup note, the data of which is also captured here.
+// Needs to stay in sync with C++ versions (PdfAccessibilityHighlightInfo and
+// PrivateAccessibilityHighlightInfo).
+// This struct contains index state that should be validated using
+// PdfAccessibilityTree::IsDataFromPluginValid() before usage.
+struct PP_PrivateAccessibilityHighlightInfo {
+  // Represents the text of the associated popup note, if present.
+  const char* note_text;
+  uint32_t note_text_length;
+  // Index of the highlight in the page annotation list. Used to identify the
+  // annotation on which action needs to be performed.
+  // |index_in_page| is populated and used in plugin process to handle
+  // accessiility actions from mimehandler process. It's value should be
+  // validated in plugin before usage.
+  uint32_t index_in_page;
+  // Highlights are annotations over existing page text.  |text_run_index|
+  // denotes the index of the text run where the highlight starts and
+  // |text_run_count| denotes the number of text runs which the highlight spans
+  // across.
+  uint32_t text_run_index;
+  uint32_t text_run_count;
+  // Bounding box of the highlight.
+  struct PP_FloatRect bounds;
+  // Color of the highlight in ARGB. Alpha is stored in the first 8 MSBs. RGB
+  // follows after it with each using 8 bytes.
+  uint32_t color;
+};
+
+// This holds text form field information provided by the PDF and will be used
+// in accessibility to expose it. Needs to stay in sync with C++ versions
+// (PdfAccessibilityTextFieldInfo and PrivateAccessibilityTextFieldInfo).
+// This struct contains index state that should be validated using
+// PdfAccessibilityTree::IsDataFromPluginValid() before usage.
+struct PP_PrivateAccessibilityTextFieldInfo {
+  // Represents the name property of text field, if present.
+  const char* name;
+  uint32_t name_length;
+  // Represents the value property of text field, if present.
+  const char* value;
+  uint32_t value_length;
+  // Represents if the text field is non-editable.
+  bool is_read_only;
+  // Represents if the field should have value at the time it is exported by a
+  // submit form action.
+  bool is_required;
+  // Represents if the text field is a password text field type.
+  bool is_password;
+  // Index of the text field in the collection of text fields in the page. Used
+  // to identify the annotation on which action needs to be performed.
+  // |index_in_page| is populated and used in plugin process to handle
+  // accessiility actions from mimehandler process. It's value should be
+  // validated in plugin before usage.
+  uint32_t index_in_page;
+  // We anchor the text field to a text run index, this denotes the text run
+  // before which the text field should be inserted in the accessibility tree.
+  uint32_t text_run_index;
+  // Bounding box of the text field.
+  struct PP_FloatRect bounds;
+};
+
+// This holds choice form field option information provided by the PDF and
+// will be used in accessibility to expose it. Needs to stay in sync with C++
+// versions (PdfAccessibilityChoiceFieldOptionInfo and
+// PrivateAccessibilityChoiceFieldOptionInfo).
+struct PP_PrivateAccessibilityChoiceFieldOptionInfo {
+  // Represents the name property of choice field option.
+  const char* name;
+  uint32_t name_length;
+  // Represents if a choice field option is selected or not.
+  bool is_selected;
+  // Bounding box of the choice field option.
+  struct PP_FloatRect bounds;
+};
+
+typedef enum {
+  PP_PRIVATECHOICEFIELD_LISTBOX = 0,
+  PP_PRIVATECHOICEFIELD_COMBOBOX = 1,
+  PP_PRIVATECHOICEFIELD_LAST = PP_PRIVATECHOICEFIELD_COMBOBOX
+} PP_PrivateChoiceFieldType;
+
+// This holds choice form field information provided by the PDF and will be used
+// in accessibility to expose it. Needs to stay in sync with C++ versions
+// (PdfAccessibilityChoiceFieldInfo and PrivateAccessibilityChoiceFieldInfo).
+// This struct contains index state that should be validated using
+// PdfAccessibilityTree::IsDataFromPluginValid() before usage.
+struct PP_PrivateAccessibilityChoiceFieldInfo {
+  // Represents the name property of choice field, if present.
+  const char* name;
+  uint32_t name_length;
+  // Represents list of options in choice field, if present.
+  struct PP_PrivateAccessibilityChoiceFieldOptionInfo* options;
+  uint32_t options_length;
+  // Represents type of choice field.
+  PP_PrivateChoiceFieldType type;
+  // Represents if the choice field is non-editable.
+  bool is_read_only;
+  // Represents if the choice field is multi-selectable.
+  bool is_multi_select;
+  // Represents if the choice field includes an editable text box.
+  bool has_editable_text_box;
+  // Index of the choice field in the collection of choice fields in the page.
+  // Used to identify the annotation on which action needs to be performed.
+  // |index_in_page| is populated and used in plugin process to handle
+  // accessiility actions from mimehandler process. It's value should be
+  // validated in plugin before usage.
+  uint32_t index_in_page;
+  // We anchor the choice field to a text run index, this denotes the text run
+  // before which the choice field should be inserted in the accessibility tree.
+  uint32_t text_run_index;
+  // Bounding box of the choice field.
+  struct PP_FloatRect bounds;
+};
+
+typedef enum {
+  PP_PRIVATEBUTTON_PUSHBUTTON = 1,
+  PP_PRIVATEBUTTON_FIRST = PP_PRIVATEBUTTON_PUSHBUTTON,
+  PP_PRIVATEBUTTON_CHECKBOX = 2,
+  PP_PRIVATEBUTTON_RADIOBUTTON = 3,
+  PP_PRIVATEBUTTON_LAST = PP_PRIVATEBUTTON_RADIOBUTTON
+} PP_PrivateButtonType;
+
+// This holds button form field information provided by the PDF and will be
+// used in accessibility to expose it. Needs to stay in sync with C++ versions
+// (PdfAccessibilityButtonInfo and PrivateAccessibilityButtonInfo).
+// This struct contains index states that should be validated using
+// PdfAccessibilityTree::IsDataFromPluginValid() before usage.
+struct PP_PrivateAccessibilityButtonInfo {
+  // Represents the name property of button, if present.
+  const char* name;
+  uint32_t name_length;
+  // Represents the value property of button, if present.
+  const char* value;
+  uint32_t value_length;
+  // Represents the button type.
+  PP_PrivateButtonType type;
+  // Represents if the button is non-editable.
+  bool is_read_only;
+  // Represents if the radio button or check box is checked or not.
+  bool is_checked;
+  // Represents count of controls in the control group. A group of interactive
+  // form annotations is collectively called a form control group. Here, an
+  // interactive form annotation, should be either a radio button or a checkbox.
+  // Value of |control_count| is >= 1.
+  uint32_t control_count;
+  // Represents index of the control in the control group. A group of
+  // interactive form annotations is collectively called a form control group.
+  // Here, an interactive form annotation, should be either a radio button or a
+  // checkbox. Value of |control_index| should always be less than
+  // |control_count|.
+  uint32_t control_index;
+  // Index of the button in the collection of buttons in the page. Used
+  // to identify the annotation on which action needs to be performed.
+  // |index_in_page| is populated and used in plugin process to handle
+  // accessiility actions from mimehandler process. It's value should be
+  // validated in plugin before usage.
+  uint32_t index_in_page;
+  // We anchor the button to a text run index, this denotes the text run
+  // before which the button should be inserted in the accessibility tree.
+  uint32_t text_run_index;
+  // Bounding box of the button.
+  struct PP_FloatRect bounds;
+};
+
+// This holds form fields within a PDF page. Needs to stay in sync with C++
+// versions (PdfAccessibilityFormFieldInfo and
+// PrivateAccessibilityFormFieldInfo).
+struct PP_PrivateAccessibilityFormFieldInfo {
+  struct PP_PrivateAccessibilityTextFieldInfo* text_fields;
+  uint32_t text_field_count;
+  struct PP_PrivateAccessibilityChoiceFieldInfo* choice_fields;
+  uint32_t choice_field_count;
+  struct PP_PrivateAccessibilityButtonInfo* buttons;
+  uint32_t button_count;
+};
+
+// This holds different PDF page objects - links, images, highlights and
+// form fields within a PDF page so that IPC messages passing accessibility
+// objects do not have too many parameters. Needs to stay in sync with C++
+// versions (PdfAccessibilityPageObjects and PrivateAccessibilityPageObjects).
+struct PP_PrivateAccessibilityPageObjects {
+  struct PP_PrivateAccessibilityLinkInfo* links;
+  uint32_t link_count;
+  struct PP_PrivateAccessibilityImageInfo* images;
+  uint32_t image_count;
+  struct PP_PrivateAccessibilityHighlightInfo* highlights;
+  uint32_t highlight_count;
+  struct PP_PrivateAccessibilityFormFieldInfo form_fields;
+};
+
 struct PPB_PDF {
   // Returns a resource identifying a font file corresponding to the given font
   // request after applying the browser-specific fallback.
@@ -103,6 +446,27 @@ struct PPB_PDF {
                                     const char** snapshot_data_out,
                                     int* snapshot_size_out);
 
+  // Sends information about the viewport to the renderer for accessibility
+  // support.
+  void (*SetAccessibilityViewportInfo)(
+      PP_Instance instance,
+      const struct PP_PrivateAccessibilityViewportInfo* viewport_info);
+
+  // Sends information about the PDF document to the renderer for accessibility
+  // support.
+  void (*SetAccessibilityDocInfo)(
+      PP_Instance instance,
+      const struct PP_PrivateAccessibilityDocInfo* doc_info);
+
+  // Sends information about one page in a PDF document to the renderer for
+  // accessibility support.
+  void (*SetAccessibilityPageInfo)(
+      PP_Instance instance,
+      const struct PP_PrivateAccessibilityPageInfo* page_info,
+      const struct PP_PrivateAccessibilityTextRunInfo text_runs[],
+      const struct PP_PrivateAccessibilityCharInfo chars[],
+      const struct PP_PrivateAccessibilityPageObjects* page_objects);
+
   // Sends information about the PDF's URL and the embedder's URL.
   void (*SetCrashData)(PP_Instance instance,
                        const char* pdf_url,
diff --git a/ppapi/c/private/ppp_pdf.h b/ppapi/c/private/ppp_pdf.h
index 0e2c592939dc4..67a6210f02f2f 100644
--- a/ppapi/c/private/ppp_pdf.h
+++ b/ppapi/c/private/ppp_pdf.h
@@ -60,6 +60,85 @@ struct PP_PdfPrintSettings_Dev {
 };
 PP_COMPILE_ASSERT_STRUCT_SIZE_IN_BYTES(PP_PdfPrintSettings_Dev, 8);
 
+typedef enum {
+  // No action specified, default value.
+  PP_PDF_ACTION_NONE = 0,
+  // Action specifying a command to scroll the rect into viewport.
+  PP_PDF_SCROLL_TO_MAKE_VISIBLE = 1,
+  // Invokes default action on a node.
+  PP_PDF_DO_DEFAULT_ACTION = 2,
+  // Action specifying a command to scroll to the global point.
+  PP_PDF_SCROLL_TO_GLOBAL_POINT = 3,
+  // Sets text selection.
+  PP_PDF_SET_SELECTION = 4,
+  // Last enum value marker.
+  PP_PDF_ACCESSIBILITYACTION_LAST = PP_PDF_SET_SELECTION
+} PP_PdfAccessibilityAction;
+PP_COMPILE_ASSERT_SIZE_IN_BYTES(PP_PdfAccessibilityAction, 4);
+
+typedef enum {
+  // No scroll alignment specified.
+  PP_PDF_SCROLL_NONE = 0,
+  // Scroll the point to the center of the viewport.
+  PP_PDF_SCROLL_ALIGNMENT_CENTER,
+  // Scroll the point to the top of the viewport.
+  PP_PDF_SCROLL_ALIGNMENT_TOP,
+  // Scroll the point to the bottom of the viewport.
+  PP_PDF_SCROLL_ALIGNMENT_BOTTOM,
+  // Scroll the point to the left of the viewport.
+  PP_PDF_SCROLL_ALIGNMENT_LEFT,
+  // Scroll the point to the right of the viewport.
+  PP_PDF_SCROLL_ALIGNMENT_RIGHT,
+  // Scroll the point to the closest edge of the viewport.
+  PP_PDF_SCROLL_ALIGNMENT_CLOSEST_EDGE,
+  // Last enum value marker.
+  PP_PDF_ACCESSIBILITYSCROLLALIGNMENT_LAST =
+      PP_PDF_SCROLL_ALIGNMENT_CLOSEST_EDGE
+} PP_PdfAccessibilityScrollAlignment;
+PP_COMPILE_ASSERT_SIZE_IN_BYTES(PP_PdfAccessibilityScrollAlignment, 4);
+
+typedef enum {
+  // No annotation type defined.
+  PP_PDF_TYPE_NONE = 0,
+  // Link annotation.
+  PP_PDF_LINK = 1,
+  // Last enum value marker.
+  PP_PDF_ACCESSIBILITY_ANNOTATIONTYPE_LAST = PP_PDF_LINK
+} PP_PdfAccessibilityAnnotationType;
+PP_COMPILE_ASSERT_SIZE_IN_BYTES(PP_PdfAccessibilityAnnotationType, 4);
+
+struct PP_PdfPageCharacterIndex {
+  // Index of PDF page.
+  uint32_t page_index;
+  // Character index within the PDF page.
+  uint32_t char_index;
+};
+PP_COMPILE_ASSERT_SIZE_IN_BYTES(PP_PdfPageCharacterIndex, 8);
+
+struct PP_PdfAccessibilityActionData {
+  // Accessibility action type.
+  PP_PdfAccessibilityAction action;
+  // Annotation type on which the action is to be performed.
+  PP_PdfAccessibilityAnnotationType annotation_type;
+  // Target point on which the action is to be performed.
+  struct PP_Point target_point;
+  // Target rect on which the action is to be performed.
+  struct PP_Rect target_rect;
+  // Index of annotation in page.
+  uint32_t annotation_index;
+  // Page index on which the link is present.
+  uint32_t page_index;
+  // Horizontal scroll alignment with respect to the viewport
+  PP_PdfAccessibilityScrollAlignment horizontal_scroll_alignment;
+  // Vertical scroll alignment with respect to the viewport
+  PP_PdfAccessibilityScrollAlignment vertical_scroll_alignment;
+  // Page and character index of start of selection.
+  PP_PdfPageCharacterIndex selection_start_index;
+  // Page and character index of exclusive end of selection.
+  PP_PdfPageCharacterIndex selection_end_index;
+};
+PP_COMPILE_ASSERT_STRUCT_SIZE_IN_BYTES(PP_PdfAccessibilityActionData, 64);
+
 struct PPP_Pdf_1_1 {
   // Returns an absolute URL if the position is over a link.
   PP_Var (*GetLinkAtPosition)(PP_Instance instance,
@@ -73,6 +152,8 @@ struct PPP_Pdf_1_1 {
       PP_Instance instance,
       PP_PdfPrintPresetOptions_Dev* options);
 
+  void (*EnableAccessibility)(PP_Instance instance);
+
   void (*SetCaretPosition)(PP_Instance instance,
                            const struct PP_FloatPoint* position);
   void (*MoveRangeSelectionExtent)(PP_Instance instance,
@@ -110,6 +191,11 @@ struct PPP_Pdf_1_1 {
   // Perform a redo operation.
   void (*Redo)(PP_Instance instance);
 
+  // Enables PDF to respond to Accessibility Actions.
+  void (*HandleAccessibilityAction)(
+      PP_Instance instance,
+      const PP_PdfAccessibilityActionData& action_data);
+
   // This is a specialized version of PPP_Printing_Dev's Begin method.
   // It functions in the same way, but takes an additional |pdf_print_settings|
   // parameter. When the PPP_Pdf interface is available, use this instead of
diff --git a/ppapi/cpp/private/pdf.cc b/ppapi/cpp/private/pdf.cc
index 08494de118add..ddfbde65f1659 100644
--- a/ppapi/cpp/private/pdf.cc
+++ b/ppapi/cpp/private/pdf.cc
@@ -18,6 +18,118 @@ template <> const char* interface_name<PPB_PDF>() {
   return PPB_PDF_INTERFACE;
 }
 
+void ConvertPrivateAccessibilityTextStyleInfo(
+    const PDF::PrivateAccessibilityTextStyleInfo& text_style,
+    PP_PrivateAccessibilityTextStyleInfo* info) {
+  info->font_name = text_style.font_name.c_str();
+  info->font_name_length = text_style.font_name.size();
+  info->font_weight = text_style.font_weight;
+  info->render_mode = text_style.render_mode;
+  info->font_size = text_style.font_size;
+  info->fill_color = text_style.fill_color;
+  info->stroke_color = text_style.stroke_color;
+  info->is_italic = text_style.is_italic;
+  info->is_bold = text_style.is_bold;
+}
+
+void ConvertPrivateAccessibilityTextRunInfo(
+    const PDF::PrivateAccessibilityTextRunInfo& text_run,
+    PP_PrivateAccessibilityTextRunInfo* info) {
+  info->len = text_run.len;
+  info->bounds = text_run.bounds;
+  info->direction = text_run.direction;
+  ConvertPrivateAccessibilityTextStyleInfo(text_run.style, &info->style);
+}
+
+void ConvertPrivateAccessibilityLinkInfo(
+    const PDF::PrivateAccessibilityLinkInfo& link,
+    PP_PrivateAccessibilityLinkInfo* info) {
+  info->url = link.url.c_str();
+  info->url_length = link.url.size();
+  info->index_in_page = link.index_in_page;
+  info->text_run_index = link.text_run_index;
+  info->text_run_count = link.text_run_count;
+  info->bounds = link.bounds;
+}
+
+void ConvertPrivateAccessibilityImageInfo(
+    const PDF::PrivateAccessibilityImageInfo& image,
+    PP_PrivateAccessibilityImageInfo* info) {
+  info->alt_text = image.alt_text.c_str();
+  info->alt_text_length = image.alt_text.size();
+  info->text_run_index = image.text_run_index;
+  info->bounds = image.bounds;
+}
+
+void ConvertPrivateAccessibilityHighlightInfo(
+    const PDF::PrivateAccessibilityHighlightInfo& highlight,
+    PP_PrivateAccessibilityHighlightInfo* info) {
+  info->note_text = highlight.note_text.c_str();
+  info->note_text_length = highlight.note_text.size();
+  info->index_in_page = highlight.index_in_page;
+  info->text_run_index = highlight.text_run_index;
+  info->text_run_count = highlight.text_run_count;
+  info->bounds = highlight.bounds;
+  info->color = highlight.color;
+}
+
+void ConvertPrivateAccessibilityTextFieldInfo(
+    const PDF::PrivateAccessibilityTextFieldInfo& text_field,
+    PP_PrivateAccessibilityTextFieldInfo* info) {
+  info->name = text_field.name.c_str();
+  info->name_length = text_field.name.size();
+  info->value = text_field.value.c_str();
+  info->value_length = text_field.value.size();
+  info->is_read_only = text_field.is_read_only;
+  info->is_required = text_field.is_required;
+  info->is_password = text_field.is_password;
+  info->index_in_page = text_field.index_in_page;
+  info->text_run_index = text_field.text_run_index;
+  info->bounds = text_field.bounds;
+}
+
+void ConvertPrivateAccessibilityChoiceFieldInfo(
+    const PDF::PrivateAccessibilityChoiceFieldInfo& choice_field,
+    PP_PrivateAccessibilityChoiceFieldInfo* info,
+    std::vector<PP_PrivateAccessibilityChoiceFieldOptionInfo>* option_info) {
+  info->name = choice_field.name.c_str();
+  info->name_length = choice_field.name.size();
+
+  option_info->resize(choice_field.options.size());
+  info->options = option_info->data();
+  for (size_t i = 0; i < choice_field.options.size(); i++) {
+    info->options[i].name = choice_field.options[i].name.c_str();
+    info->options[i].name_length = choice_field.options[i].name.size();
+    info->options[i].is_selected = choice_field.options[i].is_selected;
+    info->options[i].bounds = choice_field.options[i].bounds;
+  }
+  info->options_length = choice_field.options.size();
+  info->type = choice_field.type;
+  info->is_read_only = choice_field.is_read_only;
+  info->is_multi_select = choice_field.is_multi_select;
+  info->has_editable_text_box = choice_field.has_editable_text_box;
+  info->index_in_page = choice_field.index_in_page;
+  info->text_run_index = choice_field.text_run_index;
+  info->bounds = choice_field.bounds;
+}
+
+void ConvertPrivateAccessibilityButtonInfo(
+    const PDF::PrivateAccessibilityButtonInfo& button,
+    PP_PrivateAccessibilityButtonInfo* info) {
+  info->name = button.name.c_str();
+  info->name_length = button.name.size();
+  info->value = button.value.c_str();
+  info->value_length = button.value.size();
+  info->type = button.type;
+  info->is_read_only = button.is_read_only;
+  info->is_checked = button.is_checked;
+  info->control_count = button.control_count;
+  info->control_index = button.control_index;
+  info->index_in_page = button.index_in_page;
+  info->text_run_index = button.text_run_index;
+  info->bounds = button.bounds;
+}
+
 }  // namespace
 
 // static
@@ -175,6 +287,106 @@ void PDF::GetV8ExternalSnapshotData(const InstanceHandle& instance,
   *snapshot_size_out = 0;
 }
 
+// static
+void PDF::SetAccessibilityViewportInfo(
+    const InstanceHandle& instance,
+    const PP_PrivateAccessibilityViewportInfo* viewport_info) {
+  if (has_interface<PPB_PDF>()) {
+    get_interface<PPB_PDF>()->SetAccessibilityViewportInfo(
+        instance.pp_instance(), viewport_info);
+  }
+}
+
+// static
+void PDF::SetAccessibilityDocInfo(
+    const InstanceHandle& instance,
+    const PP_PrivateAccessibilityDocInfo* doc_info) {
+  if (has_interface<PPB_PDF>()) {
+    get_interface<PPB_PDF>()->SetAccessibilityDocInfo(instance.pp_instance(),
+                                                      doc_info);
+  }
+}
+
+// static
+void PDF::SetAccessibilityPageInfo(
+    const InstanceHandle& instance,
+    const PP_PrivateAccessibilityPageInfo* page_info,
+    const std::vector<PrivateAccessibilityTextRunInfo>& text_runs,
+    const std::vector<PP_PrivateAccessibilityCharInfo>& chars,
+    const PrivateAccessibilityPageObjects& page_objects) {
+  if (has_interface<PPB_PDF>()) {
+    std::vector<PP_PrivateAccessibilityTextRunInfo> text_run_info(
+        text_runs.size());
+    for (size_t i = 0; i < text_runs.size(); ++i)
+      ConvertPrivateAccessibilityTextRunInfo(text_runs[i], &text_run_info[i]);
+
+    const std::vector<PrivateAccessibilityLinkInfo>& links = page_objects.links;
+    std::vector<PP_PrivateAccessibilityLinkInfo> link_info(links.size());
+    for (size_t i = 0; i < links.size(); ++i)
+      ConvertPrivateAccessibilityLinkInfo(links[i], &link_info[i]);
+
+    const std::vector<PrivateAccessibilityImageInfo>& images =
+        page_objects.images;
+    std::vector<PP_PrivateAccessibilityImageInfo> image_info(images.size());
+    for (size_t i = 0; i < images.size(); ++i)
+      ConvertPrivateAccessibilityImageInfo(images[i], &image_info[i]);
+
+    const std::vector<PrivateAccessibilityHighlightInfo>& highlights =
+        page_objects.highlights;
+    std::vector<PP_PrivateAccessibilityHighlightInfo> highlight_info(
+        highlights.size());
+    for (size_t i = 0; i < highlights.size(); ++i) {
+      ConvertPrivateAccessibilityHighlightInfo(highlights[i],
+                                               &highlight_info[i]);
+    }
+
+    const std::vector<PrivateAccessibilityTextFieldInfo>& text_fields =
+        page_objects.form_fields.text_fields;
+    std::vector<PP_PrivateAccessibilityTextFieldInfo> text_field_info(
+        text_fields.size());
+    for (size_t i = 0; i < text_fields.size(); ++i) {
+      ConvertPrivateAccessibilityTextFieldInfo(text_fields[i],
+                                               &text_field_info[i]);
+    }
+
+    const std::vector<PrivateAccessibilityChoiceFieldInfo>& choice_fields =
+        page_objects.form_fields.choice_fields;
+    std::vector<PP_PrivateAccessibilityChoiceFieldInfo> choice_field_info(
+        choice_fields.size());
+    std::vector<std::vector<PP_PrivateAccessibilityChoiceFieldOptionInfo> >
+        choice_field_option_info(choice_fields.size());
+    for (size_t i = 0; i < choice_fields.size(); ++i) {
+      ConvertPrivateAccessibilityChoiceFieldInfo(choice_fields[i],
+                                                 &choice_field_info[i],
+                                                 &choice_field_option_info[i]);
+    }
+
+    const std::vector<PrivateAccessibilityButtonInfo>& buttons =
+        page_objects.form_fields.buttons;
+    std::vector<PP_PrivateAccessibilityButtonInfo> button_info(buttons.size());
+    for (size_t i = 0; i < buttons.size(); ++i)
+      ConvertPrivateAccessibilityButtonInfo(buttons[i], &button_info[i]);
+
+    PP_PrivateAccessibilityPageObjects pp_page_objects;
+    pp_page_objects.links = link_info.data();
+    pp_page_objects.link_count = link_info.size();
+    pp_page_objects.images = image_info.data();
+    pp_page_objects.image_count = image_info.size();
+    pp_page_objects.highlights = highlight_info.data();
+    pp_page_objects.highlight_count = highlight_info.size();
+    pp_page_objects.form_fields.text_fields = text_field_info.data();
+    pp_page_objects.form_fields.text_field_count = text_field_info.size();
+    pp_page_objects.form_fields.choice_fields = choice_field_info.data();
+    pp_page_objects.form_fields.choice_field_count = choice_field_info.size();
+    pp_page_objects.form_fields.buttons = button_info.data();
+    pp_page_objects.form_fields.button_count = button_info.size();
+
+    get_interface<PPB_PDF>()->SetAccessibilityPageInfo(
+        instance.pp_instance(), page_info, text_run_info.data(), chars.data(),
+        &pp_page_objects);
+  }
+}
+
 // static
 void PDF::SetCrashData(const InstanceHandle& instance,
                        const char* pdf_url,
diff --git a/ppapi/cpp/private/pdf.h b/ppapi/cpp/private/pdf.h
index 2eb96aaf08802..0853430d828a5 100644
--- a/ppapi/cpp/private/pdf.h
+++ b/ppapi/cpp/private/pdf.h
@@ -7,7 +7,11 @@
 
 #include <stdint.h>
 
+#include <string>
+#include <vector>
+
 #include "ppapi/c/private/ppb_pdf.h"
+#include "ppapi/cpp/rect.h"
 
 struct PP_BrowserFont_Trusted_Description;
 
@@ -18,6 +22,159 @@ class Var;
 
 class PDF {
  public:
+  // C++ version of PP_PrivateAccessibilityTextStyleInfo.
+  // Needs to stay in sync with the C version.
+  struct PrivateAccessibilityTextStyleInfo {
+    std::string font_name;
+    int font_weight;
+    PP_TextRenderingMode render_mode;
+    float font_size;
+    // Colors are ARGB.
+    uint32_t fill_color;
+    uint32_t stroke_color;
+    bool is_italic;
+    bool is_bold;
+  };
+
+  // C++ version of PP_PrivateAccessibilityTextRunInfo.
+  // Needs to stay in sync with the C version.
+  struct PrivateAccessibilityTextRunInfo {
+    uint32_t len;
+    struct PP_FloatRect bounds;
+    PP_PrivateDirection direction;
+    PrivateAccessibilityTextStyleInfo style;
+  };
+
+  // C++ version of PP_PrivateAccessibilityLinkInfo.
+  // Needs to stay in sync with the C version.
+  struct PrivateAccessibilityLinkInfo {
+    std::string url;
+    // Index of this link in the collection of links in the page.
+    uint32_t index_in_page;
+    // Index of the starting text run of this link in the collection of all
+    // text runs in the page.
+    uint32_t text_run_index;
+    uint32_t text_run_count;
+    FloatRect bounds;
+  };
+
+  // C++ version of PP_PrivateAccessibilityImageInfo.
+  // Needs to stay in sync with the C version.
+  struct PrivateAccessibilityImageInfo {
+    std::string alt_text;
+    uint32_t text_run_index;
+    FloatRect bounds;
+  };
+
+  // C++ version of PP_PrivateAccessibilityHighlightInfo.
+  // Needs to stay in sync with the C version.
+  struct PrivateAccessibilityHighlightInfo {
+    std::string note_text;
+    // Index of this highlight in the collection of highlights in the page.
+    uint32_t index_in_page;
+    // Index of the starting text run of this highlight in the collection of all
+    // text runs in the page.
+    uint32_t text_run_index;
+    uint32_t text_run_count;
+    FloatRect bounds;
+    // Color of the highlight in ARGB. Alpha is stored in the first 8 MSBs. RGB
+    // follows after it with each using 8 bytes.
+    uint32_t color;
+  };
+
+  // C++ version of PP_PrivateAccessibilityTextFieldInfo.
+  // Needs to stay in sync with the C version.
+  struct PrivateAccessibilityTextFieldInfo {
+    std::string name;
+    std::string value;
+    bool is_read_only;
+    bool is_required;
+    bool is_password;
+    // Index of this text field in the collection of text fields in the page.
+    uint32_t index_in_page;
+    // We anchor the text field to a text run index, this denotes the text run
+    // before which the text field should be inserted in the accessibility tree.
+    uint32_t text_run_index;
+    FloatRect bounds;
+  };
+
+  // C++ version of PP_PrivateAccessibilityChoiceFieldOptionInfo.
+  // Needs to stay in sync with the C version.
+  struct PrivateAccessibilityChoiceFieldOptionInfo {
+    std::string name;
+    bool is_selected;
+    FloatRect bounds;
+  };
+
+  // C++ version of PP_PrivateAccessibilityChoiceFieldInfo.
+  // Needs to stay in sync with the C version.
+  struct PrivateAccessibilityChoiceFieldInfo {
+    std::string name;
+    std::vector<PrivateAccessibilityChoiceFieldOptionInfo> options;
+    PP_PrivateChoiceFieldType type;
+    // Represents if the choice field is non-editable.
+    bool is_read_only;
+    // Represents if the choice field is multi-selectable.
+    bool is_multi_select;
+    // Represents if the choice field includes an editable text box.
+    bool has_editable_text_box;
+    // Index of this choice field in the collection of choice fields in the
+    // page.
+    uint32_t index_in_page;
+    // We anchor the choice field to a text run index, this denotes the text run
+    // before which the choice field should be inserted in the accessibility
+    // tree.
+    uint32_t text_run_index;
+    FloatRect bounds;
+  };
+
+  // C++ version of PP_PrivateAccessibilityButtonInfo.
+  // Needs to stay in sync with the C version.
+  struct PrivateAccessibilityButtonInfo {
+    std::string name;
+    std::string value;
+    // Represents the button type.
+    PP_PrivateButtonType type;
+    // Represents if the button is non-editable.
+    bool is_read_only;
+    // Represents if the radio button or check box is checked or not.
+    bool is_checked;
+    // Represents count of controls in the control group. A group of interactive
+    // form annotations is collectively called a form control group. Here, an
+    // interactive form annotation, should be either a radio button or a
+    // checkbox. Value of |control_count| is >= 1.
+    uint32_t control_count;
+    // Represents index of the control in the control group. A group of
+    // interactive form annotations is collectively called a form control group.
+    // Here, an interactive form annotation, should be either a radio button or
+    // a checkbox. Value of |control_index| should always be less than
+    // |control_count|.
+    uint32_t control_index;
+    // Index of this button in the collection of buttons in the page.
+    uint32_t index_in_page;
+    // We anchor the button to a text run index, this denotes the text run
+    // before which the button should be inserted in the accessibility tree.
+    uint32_t text_run_index;
+    FloatRect bounds;
+  };
+
+  // C++ version of PP_PrivateAccessibilityFormFieldInfo.
+  // Needs to stay in sync with the C version.
+  struct PrivateAccessibilityFormFieldInfo {
+    std::vector<PrivateAccessibilityTextFieldInfo> text_fields;
+    std::vector<PrivateAccessibilityChoiceFieldInfo> choice_fields;
+    std::vector<PrivateAccessibilityButtonInfo> buttons;
+  };
+
+  // C++ version of PP_PrivateAccessibilityPageObjects.
+  // Needs to stay in sync with the C version.
+  struct PrivateAccessibilityPageObjects {
+    std::vector<PrivateAccessibilityLinkInfo> links;
+    std::vector<PrivateAccessibilityImageInfo> images;
+    std::vector<PrivateAccessibilityHighlightInfo> highlights;
+    PrivateAccessibilityFormFieldInfo form_fields;
+  };
+
   // Returns true if the required interface is available.
   static bool IsAvailable();
 
@@ -60,6 +217,18 @@ class PDF {
   static void GetV8ExternalSnapshotData(const InstanceHandle& instance,
                                         const char** snapshot_data_out,
                                         int* snapshot_size_out);
+  static void SetAccessibilityViewportInfo(
+      const InstanceHandle& instance,
+      const PP_PrivateAccessibilityViewportInfo* viewport_info);
+  static void SetAccessibilityDocInfo(
+      const InstanceHandle& instance,
+      const PP_PrivateAccessibilityDocInfo* doc_info);
+  static void SetAccessibilityPageInfo(
+      const InstanceHandle& instance,
+      const PP_PrivateAccessibilityPageInfo* page_info,
+      const std::vector<PrivateAccessibilityTextRunInfo>& text_runs,
+      const std::vector<PP_PrivateAccessibilityCharInfo>& chars,
+      const PrivateAccessibilityPageObjects& page_objects);
   static void SetCrashData(const InstanceHandle& instance,
                            const char* pdf_url,
                            const char* top_level_url);
diff --git a/ppapi/proxy/pdf_resource.cc b/ppapi/proxy/pdf_resource.cc
index f2b9a2fce389d..0df6367ee181a 100644
--- a/ppapi/proxy/pdf_resource.cc
+++ b/ppapi/proxy/pdf_resource.cc
@@ -22,6 +22,7 @@
 #include "ppapi/c/private/ppb_pdf.h"
 #include "ppapi/proxy/plugin_globals.h"
 #include "ppapi/proxy/ppapi_messages.h"
+#include "ppapi/shared_impl/pdf_accessibility_shared.h"
 #include "ppapi/shared_impl/var.h"
 #include "third_party/icu/source/i18n/unicode/usearch.h"
 
@@ -197,6 +198,37 @@ void PDFResource::GetV8ExternalSnapshotData(const char** snapshot_data_out,
                                                 snapshot_size_out);
 }
 
+void PDFResource::SetAccessibilityDocInfo(
+    const PP_PrivateAccessibilityDocInfo* doc_info) {
+  Post(RENDERER, PpapiHostMsg_PDF_SetAccessibilityDocInfo(*doc_info));
+}
+
+void PDFResource::SetAccessibilityViewportInfo(
+    const PP_PrivateAccessibilityViewportInfo* viewport_info) {
+  Post(RENDERER, PpapiHostMsg_PDF_SetAccessibilityViewportInfo(*viewport_info));
+}
+
+void PDFResource::SetAccessibilityPageInfo(
+    const PP_PrivateAccessibilityPageInfo* page_info,
+    const PP_PrivateAccessibilityTextRunInfo text_runs[],
+    const PP_PrivateAccessibilityCharInfo chars[],
+    const PP_PrivateAccessibilityPageObjects* page_objects) {
+  std::vector<PP_PrivateAccessibilityCharInfo> char_vector(
+      chars, chars + page_info->char_count);
+  // Pepper APIs require us to pass strings as char*, but IPC expects
+  // std::string. Convert information for text runs style, links and images to
+  // meet these requirements.
+  std::vector<ppapi::PdfAccessibilityTextRunInfo> text_run_vector;
+  text_run_vector.reserve(page_info->text_run_count);
+  for (size_t i = 0; i < page_info->text_run_count; i++)
+    text_run_vector.emplace_back(text_runs[i]);
+  ppapi::PdfAccessibilityPageObjects ppapi_page_objects(*page_objects);
+
+  Post(RENDERER,
+       PpapiHostMsg_PDF_SetAccessibilityPageInfo(
+           *page_info, text_run_vector, char_vector, ppapi_page_objects));
+}
+
 void PDFResource::SetCrashData(const char* pdf_url, const char* top_level_url) {
   if (pdf_url) {
     static base::debug::CrashKeyString* subresource_url =
diff --git a/ppapi/proxy/pdf_resource.h b/ppapi/proxy/pdf_resource.h
index 9d0c3948824c5..8c2d9deccd43b 100644
--- a/ppapi/proxy/pdf_resource.h
+++ b/ppapi/proxy/pdf_resource.h
@@ -59,6 +59,15 @@ class PPAPI_PROXY_EXPORT PDFResource
   void SetLinkUnderCursor(const char* url) override;
   void GetV8ExternalSnapshotData(const char** snapshot_data_out,
                                  int* snapshot_size_out) override;
+  void SetAccessibilityViewportInfo(
+      const PP_PrivateAccessibilityViewportInfo* viewport_info) override;
+  void SetAccessibilityDocInfo(
+      const PP_PrivateAccessibilityDocInfo* doc_info) override;
+  void SetAccessibilityPageInfo(
+      const PP_PrivateAccessibilityPageInfo* page_info,
+      const PP_PrivateAccessibilityTextRunInfo text_runs[],
+      const PP_PrivateAccessibilityCharInfo chars[],
+      const PP_PrivateAccessibilityPageObjects* page_objects) override;
   void SetCrashData(const char* pdf_url, const char* top_level_url) override;
   void SelectionChanged(const PP_FloatPoint& left,
                         int32_t left_height,
diff --git a/ppapi/proxy/ppapi_messages.h b/ppapi/proxy/ppapi_messages.h
index 843d43ad7b683..2915f3273442d 100644
--- a/ppapi/proxy/ppapi_messages.h
+++ b/ppapi/proxy/ppapi_messages.h
@@ -75,6 +75,7 @@
 #include "ppapi/shared_impl/file_ref_create_info.h"
 #include "ppapi/shared_impl/media_stream_audio_track_shared.h"
 #include "ppapi/shared_impl/media_stream_video_track_shared.h"
+#include "ppapi/shared_impl/pdf_accessibility_shared.h"
 #include "ppapi/shared_impl/ppapi_nacl_plugin_args.h"
 #include "ppapi/shared_impl/ppapi_preferences.h"
 #include "ppapi/shared_impl/ppb_device_ref_shared.h"
@@ -130,6 +131,21 @@ IPC_ENUM_TRAITS_MIN_MAX_VALUE(PP_VideoDecoder_Profile,
 IPC_ENUM_TRAITS_MAX_VALUE(PP_VideoFrame_Format, PP_VIDEOFRAME_FORMAT_LAST)
 IPC_ENUM_TRAITS_MAX_VALUE(PP_HardwareAcceleration, PP_HARDWAREACCELERATION_LAST)
 IPC_ENUM_TRAITS_MAX_VALUE(PP_VideoProfile, PP_VIDEOPROFILE_MAX)
+IPC_ENUM_TRAITS_MAX_VALUE(PP_PrivateDirection, PP_PRIVATEDIRECTION_LAST)
+IPC_ENUM_TRAITS_MIN_MAX_VALUE(PP_TextRenderingMode,
+                              PP_TEXTRENDERINGMODE_FIRST,
+                              PP_TEXTRENDERINGMODE_LAST)
+IPC_ENUM_TRAITS_MAX_VALUE(PP_PdfAccessibilityAction,
+                          PP_PDF_ACCESSIBILITYACTION_LAST)
+IPC_ENUM_TRAITS_MAX_VALUE(PP_PdfAccessibilityScrollAlignment,
+                          PP_PDF_ACCESSIBILITYSCROLLALIGNMENT_LAST)
+IPC_ENUM_TRAITS_MAX_VALUE(PP_PdfAccessibilityAnnotationType,
+                          PP_PDF_ACCESSIBILITY_ANNOTATIONTYPE_LAST)
+IPC_ENUM_TRAITS_MAX_VALUE(PP_PrivateChoiceFieldType, PP_PRIVATECHOICEFIELD_LAST)
+IPC_ENUM_TRAITS_MIN_MAX_VALUE(PP_PrivateButtonType,
+                              PP_PRIVATEBUTTON_FIRST,
+                              PP_PRIVATEBUTTON_LAST)
+IPC_ENUM_TRAITS_MAX_VALUE(PP_PrivateFocusObjectType, PP_PRIVATEFOCUSOBJECT_LAST)
 
 IPC_STRUCT_TRAITS_BEGIN(PP_Point)
   IPC_STRUCT_TRAITS_MEMBER(x)
@@ -205,6 +221,24 @@ IPC_STRUCT_TRAITS_BEGIN(PP_PrintSettings_Dev)
   IPC_STRUCT_TRAITS_MEMBER(format)
 IPC_STRUCT_TRAITS_END()
 
+IPC_STRUCT_TRAITS_BEGIN(PP_PdfAccessibilityActionData)
+  IPC_STRUCT_TRAITS_MEMBER(action)
+  IPC_STRUCT_TRAITS_MEMBER(annotation_type)
+  IPC_STRUCT_TRAITS_MEMBER(target_point)
+  IPC_STRUCT_TRAITS_MEMBER(target_rect)
+  IPC_STRUCT_TRAITS_MEMBER(annotation_index)
+  IPC_STRUCT_TRAITS_MEMBER(page_index)
+  IPC_STRUCT_TRAITS_MEMBER(horizontal_scroll_alignment)
+  IPC_STRUCT_TRAITS_MEMBER(vertical_scroll_alignment)
+  IPC_STRUCT_TRAITS_MEMBER(selection_start_index)
+  IPC_STRUCT_TRAITS_MEMBER(selection_end_index)
+IPC_STRUCT_TRAITS_END()
+
+IPC_STRUCT_TRAITS_BEGIN(PP_PdfPageCharacterIndex)
+  IPC_STRUCT_TRAITS_MEMBER(page_index)
+  IPC_STRUCT_TRAITS_MEMBER(char_index)
+IPC_STRUCT_TRAITS_END()
+
 IPC_STRUCT_TRAITS_BEGIN(PP_PdfPrintPresetOptions_Dev)
   IPC_STRUCT_TRAITS_MEMBER(is_scaling_disabled)
   IPC_STRUCT_TRAITS_MEMBER(copies)
@@ -218,6 +252,138 @@ IPC_STRUCT_TRAITS_BEGIN(PP_PdfPrintSettings_Dev)
   IPC_STRUCT_TRAITS_MEMBER(scale_factor)
 IPC_STRUCT_TRAITS_END()
 
+IPC_STRUCT_TRAITS_BEGIN(PP_PrivateAccessibilityFocusInfo)
+  IPC_STRUCT_TRAITS_MEMBER(focused_object_type)
+  IPC_STRUCT_TRAITS_MEMBER(focused_object_page_index)
+  IPC_STRUCT_TRAITS_MEMBER(focused_annotation_index_in_page)
+IPC_STRUCT_TRAITS_END()
+
+IPC_STRUCT_TRAITS_BEGIN(PP_PrivateAccessibilityViewportInfo)
+  IPC_STRUCT_TRAITS_MEMBER(zoom)
+  IPC_STRUCT_TRAITS_MEMBER(scale)
+  IPC_STRUCT_TRAITS_MEMBER(scroll)
+  IPC_STRUCT_TRAITS_MEMBER(offset)
+  IPC_STRUCT_TRAITS_MEMBER(selection_start_page_index)
+  IPC_STRUCT_TRAITS_MEMBER(selection_start_char_index)
+  IPC_STRUCT_TRAITS_MEMBER(selection_end_page_index)
+  IPC_STRUCT_TRAITS_MEMBER(selection_end_char_index)
+  IPC_STRUCT_TRAITS_MEMBER(focus_info)
+IPC_STRUCT_TRAITS_END()
+
+IPC_STRUCT_TRAITS_BEGIN(PP_PrivateAccessibilityDocInfo)
+  IPC_STRUCT_TRAITS_MEMBER(page_count)
+  IPC_STRUCT_TRAITS_MEMBER(text_accessible)
+  IPC_STRUCT_TRAITS_MEMBER(text_copyable)
+IPC_STRUCT_TRAITS_END()
+
+IPC_STRUCT_TRAITS_BEGIN(PP_PrivateAccessibilityCharInfo)
+  IPC_STRUCT_TRAITS_MEMBER(unicode_character)
+  IPC_STRUCT_TRAITS_MEMBER(char_width)
+IPC_STRUCT_TRAITS_END()
+
+IPC_STRUCT_TRAITS_BEGIN(ppapi::PdfAccessibilityTextStyleInfo)
+  IPC_STRUCT_TRAITS_MEMBER(font_name)
+  IPC_STRUCT_TRAITS_MEMBER(font_weight)
+  IPC_STRUCT_TRAITS_MEMBER(render_mode)
+  IPC_STRUCT_TRAITS_MEMBER(font_size)
+  IPC_STRUCT_TRAITS_MEMBER(fill_color)
+  IPC_STRUCT_TRAITS_MEMBER(stroke_color)
+  IPC_STRUCT_TRAITS_MEMBER(is_italic)
+  IPC_STRUCT_TRAITS_MEMBER(is_bold)
+IPC_STRUCT_TRAITS_END()
+
+IPC_STRUCT_TRAITS_BEGIN(ppapi::PdfAccessibilityTextRunInfo)
+  IPC_STRUCT_TRAITS_MEMBER(len)
+  IPC_STRUCT_TRAITS_MEMBER(bounds)
+  IPC_STRUCT_TRAITS_MEMBER(direction)
+  IPC_STRUCT_TRAITS_MEMBER(style)
+IPC_STRUCT_TRAITS_END()
+
+IPC_STRUCT_TRAITS_BEGIN(PP_PrivateAccessibilityPageInfo)
+  IPC_STRUCT_TRAITS_MEMBER(page_index)
+  IPC_STRUCT_TRAITS_MEMBER(bounds)
+  IPC_STRUCT_TRAITS_MEMBER(text_run_count)
+  IPC_STRUCT_TRAITS_MEMBER(char_count)
+IPC_STRUCT_TRAITS_END()
+
+IPC_STRUCT_TRAITS_BEGIN(ppapi::PdfAccessibilityLinkInfo)
+  IPC_STRUCT_TRAITS_MEMBER(url)
+  IPC_STRUCT_TRAITS_MEMBER(index_in_page)
+  IPC_STRUCT_TRAITS_MEMBER(text_run_index)
+  IPC_STRUCT_TRAITS_MEMBER(text_run_count)
+  IPC_STRUCT_TRAITS_MEMBER(bounds)
+IPC_STRUCT_TRAITS_END()
+
+IPC_STRUCT_TRAITS_BEGIN(ppapi::PdfAccessibilityImageInfo)
+  IPC_STRUCT_TRAITS_MEMBER(alt_text)
+  IPC_STRUCT_TRAITS_MEMBER(text_run_index)
+  IPC_STRUCT_TRAITS_MEMBER(bounds)
+IPC_STRUCT_TRAITS_END()
+
+IPC_STRUCT_TRAITS_BEGIN(ppapi::PdfAccessibilityHighlightInfo)
+  IPC_STRUCT_TRAITS_MEMBER(note_text)
+  IPC_STRUCT_TRAITS_MEMBER(index_in_page)
+  IPC_STRUCT_TRAITS_MEMBER(text_run_index)
+  IPC_STRUCT_TRAITS_MEMBER(text_run_count)
+  IPC_STRUCT_TRAITS_MEMBER(bounds)
+  IPC_STRUCT_TRAITS_MEMBER(color)
+IPC_STRUCT_TRAITS_END()
+
+IPC_STRUCT_TRAITS_BEGIN(ppapi::PdfAccessibilityTextFieldInfo)
+  IPC_STRUCT_TRAITS_MEMBER(name)
+  IPC_STRUCT_TRAITS_MEMBER(value)
+  IPC_STRUCT_TRAITS_MEMBER(is_read_only)
+  IPC_STRUCT_TRAITS_MEMBER(is_required)
+  IPC_STRUCT_TRAITS_MEMBER(is_password)
+  IPC_STRUCT_TRAITS_MEMBER(index_in_page)
+  IPC_STRUCT_TRAITS_MEMBER(text_run_index)
+  IPC_STRUCT_TRAITS_MEMBER(bounds)
+IPC_STRUCT_TRAITS_END()
+
+IPC_STRUCT_TRAITS_BEGIN(ppapi::PdfAccessibilityChoiceFieldOptionInfo)
+  IPC_STRUCT_TRAITS_MEMBER(name)
+  IPC_STRUCT_TRAITS_MEMBER(is_selected)
+  IPC_STRUCT_TRAITS_MEMBER(bounds)
+IPC_STRUCT_TRAITS_END()
+
+IPC_STRUCT_TRAITS_BEGIN(ppapi::PdfAccessibilityChoiceFieldInfo)
+  IPC_STRUCT_TRAITS_MEMBER(name)
+  IPC_STRUCT_TRAITS_MEMBER(options)
+  IPC_STRUCT_TRAITS_MEMBER(type)
+  IPC_STRUCT_TRAITS_MEMBER(is_read_only)
+  IPC_STRUCT_TRAITS_MEMBER(is_multi_select)
+  IPC_STRUCT_TRAITS_MEMBER(has_editable_text_box)
+  IPC_STRUCT_TRAITS_MEMBER(index_in_page)
+  IPC_STRUCT_TRAITS_MEMBER(text_run_index)
+  IPC_STRUCT_TRAITS_MEMBER(bounds)
+IPC_STRUCT_TRAITS_END()
+
+IPC_STRUCT_TRAITS_BEGIN(ppapi::PdfAccessibilityButtonInfo)
+  IPC_STRUCT_TRAITS_MEMBER(name)
+  IPC_STRUCT_TRAITS_MEMBER(value)
+  IPC_STRUCT_TRAITS_MEMBER(type)
+  IPC_STRUCT_TRAITS_MEMBER(is_read_only)
+  IPC_STRUCT_TRAITS_MEMBER(is_checked)
+  IPC_STRUCT_TRAITS_MEMBER(control_count)
+  IPC_STRUCT_TRAITS_MEMBER(control_index)
+  IPC_STRUCT_TRAITS_MEMBER(index_in_page)
+  IPC_STRUCT_TRAITS_MEMBER(text_run_index)
+  IPC_STRUCT_TRAITS_MEMBER(bounds)
+IPC_STRUCT_TRAITS_END()
+
+IPC_STRUCT_TRAITS_BEGIN(ppapi::PdfAccessibilityFormFieldInfo)
+  IPC_STRUCT_TRAITS_MEMBER(text_fields)
+  IPC_STRUCT_TRAITS_MEMBER(choice_fields)
+  IPC_STRUCT_TRAITS_MEMBER(buttons)
+IPC_STRUCT_TRAITS_END()
+
+IPC_STRUCT_TRAITS_BEGIN(ppapi::PdfAccessibilityPageObjects)
+  IPC_STRUCT_TRAITS_MEMBER(links)
+  IPC_STRUCT_TRAITS_MEMBER(images)
+  IPC_STRUCT_TRAITS_MEMBER(highlights)
+  IPC_STRUCT_TRAITS_MEMBER(form_fields)
+IPC_STRUCT_TRAITS_END()
+
 IPC_STRUCT_TRAITS_BEGIN(PP_URLComponent_Dev)
   IPC_STRUCT_TRAITS_MEMBER(begin)
   IPC_STRUCT_TRAITS_MEMBER(len)
@@ -607,6 +773,8 @@ IPC_SYNC_MESSAGE_ROUTED1_2(
     PP_Instance /* instance */,
     PP_PdfPrintPresetOptions_Dev /* print preset options */,
     PP_Bool /* result */)
+IPC_MESSAGE_ROUTED1(PpapiMsg_PPPPdf_EnableAccessibility,
+                    PP_Instance /* instance */)
 IPC_MESSAGE_ROUTED2(PpapiMsg_PPPPdf_SetCaretPosition,
                     PP_Instance /* instance */,
                     PP_FloatPoint /* position */)
@@ -635,6 +803,9 @@ IPC_SYNC_MESSAGE_ROUTED1_1(PpapiMsg_PPPPdf_CanRedo,
                            PP_Bool /* result */)
 IPC_MESSAGE_ROUTED1(PpapiMsg_PPPPdf_Undo, PP_Instance /* instance */)
 IPC_MESSAGE_ROUTED1(PpapiMsg_PPPPdf_Redo, PP_Instance /* instance */)
+IPC_MESSAGE_ROUTED2(PpapiMsg_PPPPdf_HandleAccessibilityAction,
+                    PP_Instance /* instance */,
+                    PP_PdfAccessibilityActionData /* action_data */)
 IPC_SYNC_MESSAGE_ROUTED3_1(PpapiMsg_PPPPdf_PrintBegin,
                            PP_Instance /* instance */,
                            PP_PrintSettings_Dev /* print_settings */,
@@ -1914,6 +2085,24 @@ IPC_MESSAGE_CONTROL1(PpapiHostMsg_PDF_SetSelectedText,
 IPC_MESSAGE_CONTROL1(PpapiHostMsg_PDF_SetLinkUnderCursor,
                      std::string /* url */)
 
+// Called by the plugin to describe the viewport for accessibility support.
+IPC_MESSAGE_CONTROL1(
+    PpapiHostMsg_PDF_SetAccessibilityViewportInfo,
+    PP_PrivateAccessibilityViewportInfo /* viewport_info */)
+
+// Send information about the whole document for accessibility support.
+IPC_MESSAGE_CONTROL1(
+    PpapiHostMsg_PDF_SetAccessibilityDocInfo,
+    PP_PrivateAccessibilityDocInfo /* doc_info */)
+
+// Send information about one page for accessibility support.
+IPC_MESSAGE_CONTROL4(
+    PpapiHostMsg_PDF_SetAccessibilityPageInfo,
+    PP_PrivateAccessibilityPageInfo /* page_info */,
+    std::vector<ppapi::PdfAccessibilityTextRunInfo> /* text_runs */,
+    std::vector<PP_PrivateAccessibilityCharInfo> /* chars */,
+    ppapi::PdfAccessibilityPageObjects /* page_objects */)
+
 // Send information about the selection coordinates.
 IPC_MESSAGE_CONTROL4(PpapiHostMsg_PDF_SelectionChanged,
                      PP_FloatPoint /* left */,
diff --git a/ppapi/proxy/ppp_pdf_proxy.cc b/ppapi/proxy/ppp_pdf_proxy.cc
index 64984442bb248..707c99a090651 100644
--- a/ppapi/proxy/ppp_pdf_proxy.cc
+++ b/ppapi/proxy/ppp_pdf_proxy.cc
@@ -36,6 +36,11 @@ PP_Bool GetPrintPresetOptionsFromDocument(
   return ret;
 }
 
+void EnableAccessibility(PP_Instance instance) {
+  HostDispatcher::GetForInstance(instance)->Send(
+      new PpapiMsg_PPPPdf_EnableAccessibility(API_ID_PPP_PDF, instance));
+}
+
 void SetCaretPosition(PP_Instance instance, const PP_FloatPoint* position) {
   HostDispatcher::GetForInstance(instance)->Send(
       new PpapiMsg_PPPPdf_SetCaretPosition(API_ID_PPP_PDF, instance,
@@ -105,6 +110,14 @@ void Redo(PP_Instance instance) {
       new PpapiMsg_PPPPdf_Redo(API_ID_PPP_PDF, instance));
 }
 
+void HandleAccessibilityAction(
+    PP_Instance instance,
+    const PP_PdfAccessibilityActionData& action_data) {
+  HostDispatcher::GetForInstance(instance)->Send(
+      new PpapiMsg_PPPPdf_HandleAccessibilityAction(API_ID_PPP_PDF, instance,
+                                                    action_data));
+}
+
 int32_t PrintBegin(PP_Instance instance,
                    const PP_PrintSettings_Dev* print_settings,
                    const PP_PdfPrintSettings_Dev* pdf_print_settings) {
@@ -118,6 +131,7 @@ const PPP_Pdf ppp_pdf_interface = {
     &GetLinkAtPosition,
     &Transform,
     &GetPrintPresetOptionsFromDocument,
+    &EnableAccessibility,
     &SetCaretPosition,
     &MoveRangeSelectionExtent,
     &SetSelectionBounds,
@@ -129,6 +143,7 @@ const PPP_Pdf ppp_pdf_interface = {
     &CanRedo,
     &Undo,
     &Redo,
+    &HandleAccessibilityAction,
     &PrintBegin,
 };
 #else
@@ -164,6 +179,8 @@ bool PPP_Pdf_Proxy::OnMessageReceived(const IPC::Message& msg) {
     IPC_MESSAGE_HANDLER(PpapiMsg_PPPPdf_Rotate, OnPluginMsgRotate)
     IPC_MESSAGE_HANDLER(PpapiMsg_PPPPdf_PrintPresetOptions,
                         OnPluginMsgPrintPresetOptions)
+    IPC_MESSAGE_HANDLER(PpapiMsg_PPPPdf_EnableAccessibility,
+                        OnPluginMsgEnableAccessibility)
     IPC_MESSAGE_HANDLER(PpapiMsg_PPPPdf_SetCaretPosition,
                         OnPluginMsgSetCaretPosition)
     IPC_MESSAGE_HANDLER(PpapiMsg_PPPPdf_MoveRangeSelectionExtent,
@@ -180,6 +197,8 @@ bool PPP_Pdf_Proxy::OnMessageReceived(const IPC::Message& msg) {
     IPC_MESSAGE_HANDLER(PpapiMsg_PPPPdf_CanRedo, OnPluginMsgCanRedo)
     IPC_MESSAGE_HANDLER(PpapiMsg_PPPPdf_Undo, OnPluginMsgUndo)
     IPC_MESSAGE_HANDLER(PpapiMsg_PPPPdf_Redo, OnPluginMsgRedo)
+    IPC_MESSAGE_HANDLER(PpapiMsg_PPPPdf_HandleAccessibilityAction,
+                        OnPluginMsgHandleAccessibilityAction)
     IPC_MESSAGE_HANDLER(PpapiMsg_PPPPdf_PrintBegin, OnPluginMsgPrintBegin)
     IPC_MESSAGE_UNHANDLED(handled = false)
   IPC_END_MESSAGE_MAP()
@@ -204,6 +223,11 @@ void PPP_Pdf_Proxy::OnPluginMsgPrintPresetOptions(
   }
 }
 
+void PPP_Pdf_Proxy::OnPluginMsgEnableAccessibility(PP_Instance instance) {
+  if (ppp_pdf_)
+    CallWhileUnlocked(ppp_pdf_->EnableAccessibility, instance);
+}
+
 void PPP_Pdf_Proxy::OnPluginMsgSetCaretPosition(PP_Instance instance,
                                                 const PP_FloatPoint& position) {
   if (ppp_pdf_)
@@ -267,6 +291,15 @@ void PPP_Pdf_Proxy::OnPluginMsgRedo(PP_Instance instance) {
     CallWhileUnlocked(ppp_pdf_->Redo, instance);
 }
 
+void PPP_Pdf_Proxy::OnPluginMsgHandleAccessibilityAction(
+    PP_Instance instance,
+    const PP_PdfAccessibilityActionData& action_data) {
+  if (ppp_pdf_) {
+    CallWhileUnlocked(ppp_pdf_->HandleAccessibilityAction, instance,
+                      action_data);
+  }
+}
+
 void PPP_Pdf_Proxy::OnPluginMsgPrintBegin(
     PP_Instance instance,
     const PP_PrintSettings_Dev& print_settings,
diff --git a/ppapi/proxy/ppp_pdf_proxy.h b/ppapi/proxy/ppp_pdf_proxy.h
index 417035821ff7d..40cf2acbcdd4c 100644
--- a/ppapi/proxy/ppp_pdf_proxy.h
+++ b/ppapi/proxy/ppp_pdf_proxy.h
@@ -34,6 +34,7 @@ class PPP_Pdf_Proxy : public InterfaceProxy {
   void OnPluginMsgPrintPresetOptions(PP_Instance instance,
                                      PP_PdfPrintPresetOptions_Dev* options,
                                      PP_Bool* result);
+  void OnPluginMsgEnableAccessibility(PP_Instance instance);
   void OnPluginMsgSetCaretPosition(PP_Instance instance,
                                    const PP_FloatPoint& position);
   void OnPluginMsgMoveRangeSelectionExtent(PP_Instance instance,
@@ -50,6 +51,9 @@ class PPP_Pdf_Proxy : public InterfaceProxy {
   void OnPluginMsgCanRedo(PP_Instance instance, PP_Bool* result);
   void OnPluginMsgUndo(PP_Instance instance);
   void OnPluginMsgRedo(PP_Instance instance);
+  void OnPluginMsgHandleAccessibilityAction(
+      PP_Instance instance,
+      const PP_PdfAccessibilityActionData& action_data);
   void OnPluginMsgPrintBegin(PP_Instance instance,
                              const PP_PrintSettings_Dev& print_settings,
                              const PP_PdfPrintSettings_Dev& pdf_print_settings,
diff --git a/ppapi/shared_impl/BUILD.gn b/ppapi/shared_impl/BUILD.gn
index 2931e6557869b..65d2f2faebc81 100644
--- a/ppapi/shared_impl/BUILD.gn
+++ b/ppapi/shared_impl/BUILD.gn
@@ -137,6 +137,8 @@ component("shared_impl") {
     "media_stream_buffer_manager.h",
     "media_stream_video_track_shared.cc",
     "media_stream_video_track_shared.h",
+    "pdf_accessibility_shared.cc",
+    "pdf_accessibility_shared.h",
     "platform_file.cc",
     "platform_file.h",
     "ppapi_constants.h",
diff --git a/ppapi/shared_impl/OWNERS b/ppapi/shared_impl/OWNERS
new file mode 100644
index 0000000000000..c0a8863b91001
--- /dev/null
+++ b/ppapi/shared_impl/OWNERS
@@ -0,0 +1 @@
+per-file pdf_accessibility_shared.*=thestig@chromium.org
diff --git a/ppapi/shared_impl/pdf_accessibility_shared.cc b/ppapi/shared_impl/pdf_accessibility_shared.cc
new file mode 100644
index 0000000000000..9615650d81ee0
--- /dev/null
+++ b/ppapi/shared_impl/pdf_accessibility_shared.cc
@@ -0,0 +1,185 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ppapi/shared_impl/pdf_accessibility_shared.h"
+
+namespace ppapi {
+
+PdfAccessibilityTextStyleInfo::PdfAccessibilityTextStyleInfo() = default;
+
+PdfAccessibilityTextStyleInfo::PdfAccessibilityTextStyleInfo(
+    const PP_PrivateAccessibilityTextStyleInfo& style)
+    : font_name(std::string(style.font_name, style.font_name_length)),
+      font_weight(style.font_weight),
+      render_mode(style.render_mode),
+      font_size(style.font_size),
+      fill_color(style.fill_color),
+      stroke_color(style.stroke_color),
+      is_italic(style.is_italic),
+      is_bold(style.is_bold) {}
+
+PdfAccessibilityTextStyleInfo::PdfAccessibilityTextStyleInfo(
+    PdfAccessibilityTextStyleInfo&& other) = default;
+
+PdfAccessibilityTextStyleInfo::~PdfAccessibilityTextStyleInfo() = default;
+
+PdfAccessibilityTextRunInfo::PdfAccessibilityTextRunInfo() = default;
+
+PdfAccessibilityTextRunInfo::PdfAccessibilityTextRunInfo(
+    const PP_PrivateAccessibilityTextRunInfo& text_run)
+    : len(text_run.len),
+      bounds(text_run.bounds),
+      direction(text_run.direction),
+      style(text_run.style) {}
+
+PdfAccessibilityTextRunInfo::PdfAccessibilityTextRunInfo(
+    PdfAccessibilityTextRunInfo&& other) = default;
+
+PdfAccessibilityTextRunInfo::~PdfAccessibilityTextRunInfo() = default;
+
+PdfAccessibilityLinkInfo::PdfAccessibilityLinkInfo() = default;
+
+PdfAccessibilityLinkInfo::PdfAccessibilityLinkInfo(
+    const PP_PrivateAccessibilityLinkInfo& link)
+    : url(std::string(link.url, link.url_length)),
+      index_in_page(link.index_in_page),
+      text_run_index(link.text_run_index),
+      text_run_count(link.text_run_count),
+      bounds(link.bounds) {}
+
+PdfAccessibilityLinkInfo::~PdfAccessibilityLinkInfo() = default;
+
+PdfAccessibilityImageInfo::PdfAccessibilityImageInfo() = default;
+
+PdfAccessibilityImageInfo::PdfAccessibilityImageInfo(
+    const PP_PrivateAccessibilityImageInfo& image)
+    : alt_text(std::string(image.alt_text, image.alt_text_length)),
+      text_run_index(image.text_run_index),
+      bounds(image.bounds) {}
+
+PdfAccessibilityImageInfo::~PdfAccessibilityImageInfo() = default;
+
+PdfAccessibilityHighlightInfo::PdfAccessibilityHighlightInfo() = default;
+
+PdfAccessibilityHighlightInfo::~PdfAccessibilityHighlightInfo() = default;
+
+PdfAccessibilityHighlightInfo::PdfAccessibilityHighlightInfo(
+    const PP_PrivateAccessibilityHighlightInfo& highlight)
+    : note_text(std::string(highlight.note_text, highlight.note_text_length)),
+      index_in_page(highlight.index_in_page),
+      text_run_index(highlight.text_run_index),
+      text_run_count(highlight.text_run_count),
+      bounds(highlight.bounds),
+      color(highlight.color) {}
+
+PdfAccessibilityTextFieldInfo::PdfAccessibilityTextFieldInfo() = default;
+
+PdfAccessibilityTextFieldInfo::~PdfAccessibilityTextFieldInfo() = default;
+
+PdfAccessibilityTextFieldInfo::PdfAccessibilityTextFieldInfo(
+    const PP_PrivateAccessibilityTextFieldInfo& text_field)
+    : name(std::string(text_field.name, text_field.name_length)),
+      value(std::string(text_field.value, text_field.value_length)),
+      is_read_only(text_field.is_read_only),
+      is_required(text_field.is_required),
+      is_password(text_field.is_password),
+      index_in_page(text_field.index_in_page),
+      text_run_index(text_field.text_run_index),
+      bounds(text_field.bounds) {}
+
+PdfAccessibilityChoiceFieldOptionInfo::PdfAccessibilityChoiceFieldOptionInfo() =
+    default;
+
+PdfAccessibilityChoiceFieldOptionInfo::
+    ~PdfAccessibilityChoiceFieldOptionInfo() = default;
+
+PdfAccessibilityChoiceFieldOptionInfo::PdfAccessibilityChoiceFieldOptionInfo(
+    const PP_PrivateAccessibilityChoiceFieldOptionInfo& option)
+    : name(std::string(option.name, option.name_length)),
+      is_selected(option.is_selected),
+      bounds(option.bounds) {}
+
+PdfAccessibilityChoiceFieldInfo::PdfAccessibilityChoiceFieldInfo() = default;
+
+PdfAccessibilityChoiceFieldInfo::~PdfAccessibilityChoiceFieldInfo() = default;
+
+PdfAccessibilityChoiceFieldInfo::PdfAccessibilityChoiceFieldInfo(
+    const PP_PrivateAccessibilityChoiceFieldInfo& choice_field)
+    : name(std::string(choice_field.name, choice_field.name_length)),
+      type(choice_field.type),
+      is_read_only(choice_field.is_read_only),
+      is_multi_select(choice_field.is_multi_select),
+      has_editable_text_box(choice_field.has_editable_text_box),
+      index_in_page(choice_field.index_in_page),
+      text_run_index(choice_field.text_run_index),
+      bounds(choice_field.bounds) {
+  options.reserve(choice_field.options_length);
+  for (size_t i = 0; i < choice_field.options_length; i++) {
+    options.emplace_back(choice_field.options[i]);
+  }
+}
+
+PdfAccessibilityButtonInfo::PdfAccessibilityButtonInfo() = default;
+
+PdfAccessibilityButtonInfo::~PdfAccessibilityButtonInfo() = default;
+
+PdfAccessibilityButtonInfo::PdfAccessibilityButtonInfo(
+    const PP_PrivateAccessibilityButtonInfo& button)
+    : name(std::string(button.name, button.name_length)),
+      value(std::string(button.value, button.value_length)),
+      type(button.type),
+      is_read_only(button.is_read_only),
+      is_checked(button.is_checked),
+      control_count(button.control_count),
+      control_index(button.control_index),
+      index_in_page(button.index_in_page),
+      text_run_index(button.text_run_index),
+      bounds(button.bounds) {}
+
+PdfAccessibilityFormFieldInfo::PdfAccessibilityFormFieldInfo() = default;
+
+PdfAccessibilityFormFieldInfo::PdfAccessibilityFormFieldInfo(
+    const PP_PrivateAccessibilityFormFieldInfo& form_fields) {
+  text_fields.reserve(form_fields.text_field_count);
+  for (size_t i = 0; i < form_fields.text_field_count; i++) {
+    text_fields.emplace_back(form_fields.text_fields[i]);
+  }
+
+  choice_fields.reserve(form_fields.choice_field_count);
+  for (size_t i = 0; i < form_fields.choice_field_count; i++) {
+    choice_fields.emplace_back(form_fields.choice_fields[i]);
+  }
+
+  buttons.reserve(form_fields.button_count);
+  for (size_t i = 0; i < form_fields.button_count; i++) {
+    buttons.emplace_back(form_fields.buttons[i]);
+  }
+}
+
+PdfAccessibilityFormFieldInfo::~PdfAccessibilityFormFieldInfo() = default;
+
+PdfAccessibilityPageObjects::PdfAccessibilityPageObjects() = default;
+
+PdfAccessibilityPageObjects::PdfAccessibilityPageObjects(
+    const PP_PrivateAccessibilityPageObjects& page_objects)
+    : form_fields(page_objects.form_fields) {
+  links.reserve(page_objects.link_count);
+  for (size_t i = 0; i < page_objects.link_count; i++) {
+    links.emplace_back(page_objects.links[i]);
+  }
+
+  images.reserve(page_objects.image_count);
+  for (size_t i = 0; i < page_objects.image_count; i++) {
+    images.emplace_back(page_objects.images[i]);
+  }
+
+  highlights.reserve(page_objects.highlight_count);
+  for (size_t i = 0; i < page_objects.highlight_count; i++) {
+    highlights.emplace_back(page_objects.highlights[i]);
+  }
+}
+
+PdfAccessibilityPageObjects::~PdfAccessibilityPageObjects() = default;
+
+}  // namespace ppapi
diff --git a/ppapi/shared_impl/pdf_accessibility_shared.h b/ppapi/shared_impl/pdf_accessibility_shared.h
new file mode 100644
index 0000000000000..b49ab5be6bc9e
--- /dev/null
+++ b/ppapi/shared_impl/pdf_accessibility_shared.h
@@ -0,0 +1,186 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef PPAPI_SHARED_IMPL_PDF_ACCESSIBILITY_SHARED_H_
+#define PPAPI_SHARED_IMPL_PDF_ACCESSIBILITY_SHARED_H_
+
+#include <string>
+#include <vector>
+
+#include "ppapi/c/pp_rect.h"
+#include "ppapi/c/private/ppb_pdf.h"
+#include "ppapi/shared_impl/ppapi_shared_export.h"
+
+namespace ppapi {
+
+// Needs to stay in sync with PP_PrivateAccessibilityTextStyleInfo.
+struct PPAPI_SHARED_EXPORT PdfAccessibilityTextStyleInfo {
+ public:
+  PdfAccessibilityTextStyleInfo();
+  explicit PdfAccessibilityTextStyleInfo(
+      const PP_PrivateAccessibilityTextStyleInfo& style);
+  PdfAccessibilityTextStyleInfo(PdfAccessibilityTextStyleInfo&& other);
+  ~PdfAccessibilityTextStyleInfo();
+
+  std::string font_name;
+  int font_weight;
+  PP_TextRenderingMode render_mode;
+  float font_size;
+  // Colors are ARGB.
+  uint32_t fill_color;
+  uint32_t stroke_color;
+  bool is_italic;
+  bool is_bold;
+};
+
+// Needs to stay in sync with PP_PrivateAccessibilityTextRunInfo.
+struct PPAPI_SHARED_EXPORT PdfAccessibilityTextRunInfo {
+ public:
+  PdfAccessibilityTextRunInfo();
+  explicit PdfAccessibilityTextRunInfo(
+      const PP_PrivateAccessibilityTextRunInfo& text_run);
+  PdfAccessibilityTextRunInfo(PdfAccessibilityTextRunInfo&& other);
+  ~PdfAccessibilityTextRunInfo();
+
+  uint32_t len;
+  struct PP_FloatRect bounds;
+  PP_PrivateDirection direction;
+  PdfAccessibilityTextStyleInfo style;
+};
+
+// Needs to stay in sync with PP_PrivateAccessibilityLinkInfo.
+struct PPAPI_SHARED_EXPORT PdfAccessibilityLinkInfo {
+  PdfAccessibilityLinkInfo();
+  explicit PdfAccessibilityLinkInfo(
+      const PP_PrivateAccessibilityLinkInfo& link);
+  ~PdfAccessibilityLinkInfo();
+
+  std::string url;
+  uint32_t index_in_page;
+  uint32_t text_run_index;
+  uint32_t text_run_count;
+  PP_FloatRect bounds;
+};
+
+// Needs to stay in sync with PP_PrivateAccessibilityImageInfo.
+struct PPAPI_SHARED_EXPORT PdfAccessibilityImageInfo {
+  PdfAccessibilityImageInfo();
+  explicit PdfAccessibilityImageInfo(
+      const PP_PrivateAccessibilityImageInfo& image);
+  ~PdfAccessibilityImageInfo();
+
+  std::string alt_text;
+  uint32_t text_run_index;
+  PP_FloatRect bounds;
+};
+
+// Needs to stay in sync with PP_PrivateAccessibilityHighlightInfo.
+struct PPAPI_SHARED_EXPORT PdfAccessibilityHighlightInfo {
+  PdfAccessibilityHighlightInfo();
+  explicit PdfAccessibilityHighlightInfo(
+      const PP_PrivateAccessibilityHighlightInfo& highlight);
+  ~PdfAccessibilityHighlightInfo();
+
+  std::string note_text;
+  uint32_t index_in_page;
+  uint32_t text_run_index;
+  uint32_t text_run_count;
+  PP_FloatRect bounds;
+  uint32_t color;
+};
+
+// Needs to stay in sync with PP_PrivateAccessibilityTextFieldInfo.
+struct PPAPI_SHARED_EXPORT PdfAccessibilityTextFieldInfo {
+  PdfAccessibilityTextFieldInfo();
+  explicit PdfAccessibilityTextFieldInfo(
+      const PP_PrivateAccessibilityTextFieldInfo& text_field);
+  ~PdfAccessibilityTextFieldInfo();
+
+  std::string name;
+  std::string value;
+  bool is_read_only;
+  bool is_required;
+  bool is_password;
+  uint32_t index_in_page;
+  uint32_t text_run_index;
+  PP_FloatRect bounds;
+};
+
+// Needs to stay in sync with PP_PrivateAccessibilityChoiceFieldOptionInfo.
+struct PPAPI_SHARED_EXPORT PdfAccessibilityChoiceFieldOptionInfo {
+  PdfAccessibilityChoiceFieldOptionInfo();
+  explicit PdfAccessibilityChoiceFieldOptionInfo(
+      const PP_PrivateAccessibilityChoiceFieldOptionInfo& option);
+  ~PdfAccessibilityChoiceFieldOptionInfo();
+
+  std::string name;
+  bool is_selected;
+  PP_FloatRect bounds;
+};
+
+// Needs to stay in sync with PP_PrivateAccessibilityChoiceFieldInfo.
+struct PPAPI_SHARED_EXPORT PdfAccessibilityChoiceFieldInfo {
+  PdfAccessibilityChoiceFieldInfo();
+  explicit PdfAccessibilityChoiceFieldInfo(
+      const PP_PrivateAccessibilityChoiceFieldInfo& choice_field);
+  ~PdfAccessibilityChoiceFieldInfo();
+
+  std::string name;
+  std::vector<PdfAccessibilityChoiceFieldOptionInfo> options;
+  PP_PrivateChoiceFieldType type;
+  bool is_read_only;
+  bool is_multi_select;
+  bool has_editable_text_box;
+  uint32_t index_in_page;
+  uint32_t text_run_index;
+  PP_FloatRect bounds;
+};
+
+// Needs to stay in sync with PP_PrivateAccessibilityButtonInfo.
+struct PPAPI_SHARED_EXPORT PdfAccessibilityButtonInfo {
+  PdfAccessibilityButtonInfo();
+  explicit PdfAccessibilityButtonInfo(
+      const PP_PrivateAccessibilityButtonInfo& button);
+  ~PdfAccessibilityButtonInfo();
+
+  std::string name;
+  std::string value;
+  PP_PrivateButtonType type;
+  bool is_read_only;
+  bool is_checked;
+  uint32_t control_count;
+  uint32_t control_index;
+  uint32_t index_in_page;
+  uint32_t text_run_index;
+  PP_FloatRect bounds;
+};
+
+// Needs to stay in sync with PP_PrivateAccessibilityFormFieldInfo.
+struct PPAPI_SHARED_EXPORT PdfAccessibilityFormFieldInfo {
+  PdfAccessibilityFormFieldInfo();
+  explicit PdfAccessibilityFormFieldInfo(
+      const PP_PrivateAccessibilityFormFieldInfo& form_fields);
+  ~PdfAccessibilityFormFieldInfo();
+
+  std::vector<PdfAccessibilityTextFieldInfo> text_fields;
+  std::vector<PdfAccessibilityChoiceFieldInfo> choice_fields;
+  std::vector<PdfAccessibilityButtonInfo> buttons;
+};
+
+// Needs to stay in sync with PP_PrivateAccessibilityPageObjects.
+struct PPAPI_SHARED_EXPORT PdfAccessibilityPageObjects {
+  PdfAccessibilityPageObjects();
+  explicit PdfAccessibilityPageObjects(
+      const PP_PrivateAccessibilityPageObjects& page_objects);
+  ~PdfAccessibilityPageObjects();
+
+  std::vector<PdfAccessibilityLinkInfo> links;
+  std::vector<PdfAccessibilityImageInfo> images;
+  std::vector<PdfAccessibilityHighlightInfo> highlights;
+  PdfAccessibilityFormFieldInfo form_fields;
+};
+
+}  // namespace ppapi
+
+#endif  // PPAPI_SHARED_IMPL_PDF_ACCESSIBILITY_SHARED_H_
diff --git a/ppapi/thunk/ppb_pdf_api.h b/ppapi/thunk/ppb_pdf_api.h
index aeb033cd1b2bb..2a3f6ce290697 100644
--- a/ppapi/thunk/ppb_pdf_api.h
+++ b/ppapi/thunk/ppb_pdf_api.h
@@ -34,6 +34,15 @@ class PPB_PDF_API {
   virtual void SetLinkUnderCursor(const char* url) = 0;
   virtual void GetV8ExternalSnapshotData(const char** snapshot_data_out,
                                          int* snapshot_size_out) = 0;
+  virtual void SetAccessibilityViewportInfo(
+      const PP_PrivateAccessibilityViewportInfo* viewport_info) = 0;
+  virtual void SetAccessibilityDocInfo(
+      const PP_PrivateAccessibilityDocInfo* doc_info) = 0;
+  virtual void SetAccessibilityPageInfo(
+      const PP_PrivateAccessibilityPageInfo* page_info,
+      const PP_PrivateAccessibilityTextRunInfo text_runs[],
+      const PP_PrivateAccessibilityCharInfo chars[],
+      const PP_PrivateAccessibilityPageObjects* page_objects) = 0;
   virtual void SetCrashData(const char* pdf_url, const char* top_level_url) = 0;
   virtual void SelectionChanged(const PP_FloatPoint& left,
                                 int32_t left_height,
diff --git a/ppapi/thunk/ppb_pdf_thunk.cc b/ppapi/thunk/ppb_pdf_thunk.cc
index 464a022d971c3..5928448ba888b 100644
--- a/ppapi/thunk/ppb_pdf_thunk.cc
+++ b/ppapi/thunk/ppb_pdf_thunk.cc
@@ -150,6 +150,36 @@ void GetV8ExternalSnapshotData(PP_Instance instance,
                                                snapshot_size_out);
 }
 
+void SetAccessibilityViewportInfo(
+    PP_Instance instance,
+    const PP_PrivateAccessibilityViewportInfo* viewport_info) {
+  EnterInstanceAPI<PPB_PDF_API> enter(instance);
+  if (enter.failed())
+    return;
+  enter.functions()->SetAccessibilityViewportInfo(viewport_info);
+}
+
+void SetAccessibilityDocInfo(PP_Instance instance,
+                             const PP_PrivateAccessibilityDocInfo* doc_info) {
+  EnterInstanceAPI<PPB_PDF_API> enter(instance);
+  if (enter.failed())
+    return;
+  enter.functions()->SetAccessibilityDocInfo(doc_info);
+}
+
+void SetAccessibilityPageInfo(
+    PP_Instance instance,
+    const PP_PrivateAccessibilityPageInfo* page_info,
+    const PP_PrivateAccessibilityTextRunInfo text_runs[],
+    const PP_PrivateAccessibilityCharInfo chars[],
+    const PP_PrivateAccessibilityPageObjects* page_objects) {
+  EnterInstanceAPI<PPB_PDF_API> enter(instance);
+  if (enter.failed())
+    return;
+  enter.functions()->SetAccessibilityPageInfo(page_info, text_runs, chars,
+                                              page_objects);
+}
+
 void SetCrashData(PP_Instance instance,
                   const char* pdf_url,
                   const char* top_level_url) {
@@ -192,6 +222,9 @@ const PPB_PDF g_ppb_pdf_thunk = {
     &SetSelectedText,
     &SetLinkUnderCursor,
     &GetV8ExternalSnapshotData,
+    &SetAccessibilityViewportInfo,
+    &SetAccessibilityDocInfo,
+    &SetAccessibilityPageInfo,
     &SetCrashData,
     &SelectionChanged,
     &SetPluginCanSave,

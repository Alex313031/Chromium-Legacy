diff --git a/content/browser/renderer_host/render_process_host_impl.cc b/content/browser/renderer_host/render_process_host_impl.cc
index 8defff77c5764..653f625b334ef 100644
--- a/content/browser/renderer_host/render_process_host_impl.cc
+++ b/content/browser/renderer_host/render_process_host_impl.cc
@@ -1171,6 +1171,56 @@ RenderProcessHostImpl::DomStorageBinder& GetDomStorageBinder() {
   return *binder;
 }
 
+// Keep track of plugin process IDs that require exceptions for particular
+// initiator origins.
+struct PluginExceptionsForNetworkService {
+  std::set<url::Origin> allowed_request_initiators;
+};
+std::map<int, PluginExceptionsForNetworkService>&
+GetPluginExceptionsForNetworkService() {
+  static base::NoDestructor<std::map<int, PluginExceptionsForNetworkService>>
+      s_data;
+  return *s_data;
+}
+
+void OnNetworkServiceCrashRestorePluginExceptions() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  network::mojom::NetworkService* network_service = GetNetworkService();
+  for (auto it : GetPluginExceptionsForNetworkService()) {
+    const int process_id = it.first;
+    const PluginExceptionsForNetworkService& exceptions = it.second;
+
+    for (const url::Origin& origin : exceptions.allowed_request_initiators)
+      network_service->AddAllowedRequestInitiatorForPlugin(process_id, origin);
+  }
+}
+
+void RemoveNetworkServicePluginExceptions(int process_id) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  GetPluginExceptionsForNetworkService().erase(process_id);
+  GetNetworkService()->RemoveSecurityExceptionsForPlugin(process_id);
+}
+
+bool PrepareToAddNewPluginExceptions(int process_id) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  RenderProcessHost* process = RenderProcessHostImpl::FromID(process_id);
+  if (!process)
+    return false;  // failure
+
+  process->CleanupNetworkServicePluginExceptionsUponDestruction();
+
+  static base::NoDestructor<base::CallbackListSubscription>
+      s_crash_handler_subscription;
+  if (!(*s_crash_handler_subscription)) {
+    *s_crash_handler_subscription = RegisterNetworkServiceCrashHandler(
+        base::BindRepeating(&OnNetworkServiceCrashRestorePluginExceptions));
+  }
+
+  return true;  // success
+}
+
 #if !BUILDFLAG(IS_ANDROID)
 static constexpr size_t kUnknownPlatformProcessLimit = 0;
 
@@ -1664,6 +1714,9 @@ RenderProcessHostImpl::~RenderProcessHostImpl() {
       "BrowserRenderProcessHost.MaxOutermostMainFrames",
       max_outermost_main_frames_);
 
+  if (cleanup_network_service_plugin_exceptions_upon_destruction_)
+    RemoveNetworkServicePluginExceptions(GetID());
+
   // "Cleanup in progress"
   TRACE_EVENT_END("shutdown", perfetto::Track::FromPointer(this),
                   ChromeTrackEvent::kRenderProcessHost, *this);
@@ -2152,6 +2205,27 @@ bool RenderProcessHostImpl::IsProcessShutdownDelayedForTesting() {
   return delayed_shutdown_tracker->ContainsHost(GetID());
 }
 
+// static
+void RenderProcessHostImpl::AddAllowedRequestInitiatorForPlugin(
+    int process_id,
+    const url::Origin& allowed_request_initiator) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  if (!PrepareToAddNewPluginExceptions(process_id))
+    return;
+
+  GetPluginExceptionsForNetworkService()[process_id]
+      .allowed_request_initiators.insert(allowed_request_initiator);
+  GetNetworkService()->AddAllowedRequestInitiatorForPlugin(
+      process_id, allowed_request_initiator);
+}
+
+void RenderProcessHostImpl::
+    CleanupNetworkServicePluginExceptionsUponDestruction() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  cleanup_network_service_plugin_exceptions_upon_destruction_ = true;
+}
+
 std::string
 RenderProcessHostImpl::GetInfoForBrowserContextDestructionCrashReporting() {
   std::string ret = " pl='" + GetProcessLock().ToString() + "'";
diff --git a/content/browser/renderer_host/render_process_host_impl.h b/content/browser/renderer_host/render_process_host_impl.h
index a5ac7bd79dcfc..cc4e5236ee9d4 100644
--- a/content/browser/renderer_host/render_process_host_impl.h
+++ b/content/browser/renderer_host/render_process_host_impl.h
@@ -291,6 +291,7 @@ class CONTENT_EXPORT RenderProcessHostImpl
       base::WeakPtr<BucketContext> bucket_context,
       mojo::PendingReceiver<blink::mojom::BucketManagerHost> receiver) override;
   void ForceCrash() override;
+  void CleanupNetworkServicePluginExceptionsUponDestruction() override;
   std::string GetInfoForBrowserContextDestructionCrashReporting() override;
   void WriteIntoTrace(perfetto::TracedProto<TraceProto> proto) const override;
 #if BUILDFLAG(CLANG_PROFILING_INSIDE_SANDBOX)
@@ -667,6 +668,16 @@ class CONTENT_EXPORT RenderProcessHostImpl
       mojo::PendingReceiver<network::mojom::P2PSocketManager> receiver,
       GlobalRenderFrameHostId render_frame_host_id);
 
+  // Allows |process_id| to use an additional |allowed_request_initiator|
+  // (bypassing |request_initiator_origin_lock| enforcement).
+  //
+  // The exception will be removed when the corresponding RenderProcessHostImpl
+  // is destroyed (see
+  // |cleanup_network_service_plugin_exceptions_upon_destruction_|).
+  static void AddAllowedRequestInitiatorForPlugin(
+      int process_id,
+      const url::Origin& allowed_request_initiator);
+
   using IpcSendWatcher = base::RepeatingCallback<void(const IPC::Message& msg)>;
   void SetIpcSendWatcherForTesting(IpcSendWatcher watcher) {
     ipc_send_watcher_for_testing_ = std::move(watcher);
@@ -1150,6 +1161,8 @@ class CONTENT_EXPORT RenderProcessHostImpl
   std::unique_ptr<mojo::Receiver<viz::mojom::CompositingModeReporter>>
       compositing_mode_reporter_;
 
+  bool cleanup_network_service_plugin_exceptions_upon_destruction_ = false;
+
   // Stores the amount of time that this RenderProcessHost's shutdown has been
   // delayed to run unload handlers, or zero if the process shutdown was not
   // delayed due to unload handlers.
diff --git a/content/browser/web_package/subresource_signed_exchange_url_loader_factory.cc b/content/browser/web_package/subresource_signed_exchange_url_loader_factory.cc
index be31d3ed6eaa0..0d84eafcbb3d7 100644
--- a/content/browser/web_package/subresource_signed_exchange_url_loader_factory.cc
+++ b/content/browser/web_package/subresource_signed_exchange_url_loader_factory.cc
@@ -75,7 +75,9 @@ bool IsValidRequestInitiator(const network::ResourceRequest& request,
                                           request.request_initiator);
   switch (initiator_lock_compatibility) {
     case network::InitiatorLockCompatibility::kBrowserProcess:
-      // kBrowserProcess cannot happen outside of NetworkService.
+    case network::InitiatorLockCompatibility::kAllowedRequestInitiatorForPlugin:
+      // kBrowserProcess and kAllowedRequestInitiatorForPlugin cannot happen
+      // outside of NetworkService.
       NOTREACHED();
 
     case network::InitiatorLockCompatibility::kNoLock:
diff --git a/content/public/browser/render_process_host.h b/content/public/browser/render_process_host.h
index b1889a548d92c..c9966614c64d6 100644
--- a/content/public/browser/render_process_host.h
+++ b/content/public/browser/render_process_host.h
@@ -618,6 +618,16 @@ class CONTENT_EXPORT RenderProcessHost : public IPC::Sender,
   // Forces the renderer process to crash ASAP.
   virtual void ForceCrash() {}
 
+  // Controls whether the destructor of RenderProcessHost*Impl* will end up
+  // cleaning the memory used by the exception added via
+  // RenderProcessHostImpl::AddAllowedRequestInitiatorForPlugin.
+  //
+  // TODO(lukasza): https://crbug.com/652474: This method shouldn't be part of
+  // the //content public API, because it shouldn't be called by anyone other
+  // than RenderProcessHostImpl (from underneath
+  // RenderProcessHostImpl::AddAllowedRequestInitiatorForPlugin).
+  virtual void CleanupNetworkServicePluginExceptionsUponDestruction() = 0;
+
   // Returns a string that contains information useful for debugging
   // crashes related to RenderProcessHost objects staying alive longer than
   // the BrowserContext they are associated with.
diff --git a/content/public/test/mock_render_process_host.cc b/content/public/test/mock_render_process_host.cc
index a1fc9926b79ed..ece4e64edb5d8 100644
--- a/content/public/test/mock_render_process_host.cc
+++ b/content/public/test/mock_render_process_host.cc
@@ -528,6 +528,9 @@ void MockRenderProcessHost::BindIndexedDB(
   std::move(callback).Run(file_system_access_error::Ok(), {});
 }
 
+void MockRenderProcessHost::
+    CleanupNetworkServicePluginExceptionsUponDestruction() {}
+
 std::string
 MockRenderProcessHost::GetInfoForBrowserContextDestructionCrashReporting() {
   return std::string();
diff --git a/content/public/test/mock_render_process_host.h b/content/public/test/mock_render_process_host.h
index d41b9e0381af2..ca2ec3a2cfda4 100644
--- a/content/public/test/mock_render_process_host.h
+++ b/content/public/test/mock_render_process_host.h
@@ -251,6 +251,7 @@ class MockRenderProcessHost : public RenderProcessHost {
       override {}
 #endif  // BUILDFLAG(ALLOW_OOP_VIDEO_DECODER)
 
+  void CleanupNetworkServicePluginExceptionsUponDestruction() override;
   std::string GetInfoForBrowserContextDestructionCrashReporting() override;
   void WriteIntoTrace(perfetto::TracedProto<TraceProto> proto) const override;
 
diff --git a/services/network/cors/cors_url_loader_factory.cc b/services/network/cors/cors_url_loader_factory.cc
index 492c8197219f4..ef365780b9416 100644
--- a/services/network/cors/cors_url_loader_factory.cc
+++ b/services/network/cors/cors_url_loader_factory.cc
@@ -473,16 +473,13 @@ bool CorsURLLoaderFactory::IsValidRequest(const ResourceRequest& request,
 
   // Depending on the type of request, compare either `request_initiator` or
   // `request.url` to `request_initiator_origin_lock_`.
-  InitiatorLockCompatibility initiator_lock_compatibility;
-  if (process_id_ == mojom::kBrowserProcessId) {
-    initiator_lock_compatibility = InitiatorLockCompatibility::kBrowserProcess;
-  } else {
-    initiator_lock_compatibility = VerifyRequestInitiatorLock(
-        request_initiator_origin_lock_, origin_to_validate);
-  }
+  InitiatorLockCompatibility initiator_lock_compatibility =
+      VerifyRequestInitiatorLockWithPluginCheck(
+          process_id_, request_initiator_origin_lock_, origin_to_validate);
   switch (initiator_lock_compatibility) {
     case InitiatorLockCompatibility::kCompatibleLock:
     case InitiatorLockCompatibility::kBrowserProcess:
+    case InitiatorLockCompatibility::kAllowedRequestInitiatorForPlugin:
       break;
 
     case InitiatorLockCompatibility::kNoLock:
@@ -611,6 +608,27 @@ bool CorsURLLoaderFactory::IsValidRequest(const ResourceRequest& request,
   return true;
 }
 
+InitiatorLockCompatibility
+CorsURLLoaderFactory::VerifyRequestInitiatorLockWithPluginCheck(
+    uint32_t process_id,
+    const std::optional<url::Origin>& request_initiator_origin_lock,
+    const std::optional<url::Origin>& request_initiator) {
+  if (process_id == mojom::kBrowserProcessId)
+    return InitiatorLockCompatibility::kBrowserProcess;
+
+  InitiatorLockCompatibility result = VerifyRequestInitiatorLock(
+      request_initiator_origin_lock, request_initiator);
+
+  if (result == InitiatorLockCompatibility::kIncorrectLock &&
+      request_initiator.has_value() &&
+      context_->network_service()->IsInitiatorAllowedForPlugin(
+          process_id, request_initiator.value())) {
+    result = InitiatorLockCompatibility::kAllowedRequestInitiatorForPlugin;
+  }
+
+  return result;
+}
+
 bool CorsURLLoaderFactory::GetAllowAnyCorsExemptHeaderForBrowser() const {
   return process_id_ == mojom::kBrowserProcessId &&
          context_->allow_any_cors_exempt_header_for_browser();
diff --git a/services/network/cors/cors_url_loader_factory.h b/services/network/cors/cors_url_loader_factory.h
index cb959d7919ba4..7d346a28854bf 100644
--- a/services/network/cors/cors_url_loader_factory.h
+++ b/services/network/cors/cors_url_loader_factory.h
@@ -102,6 +102,11 @@ class COMPONENT_EXPORT(NETWORK_SERVICE) CorsURLLoaderFactory final
 
   bool IsValidRequest(const ResourceRequest& request, uint32_t options);
 
+  InitiatorLockCompatibility VerifyRequestInitiatorLockWithPluginCheck(
+      uint32_t process_id,
+      const std::optional<url::Origin>& request_initiator_origin_lock,
+      const std::optional<url::Origin>& request_initiator);
+
   bool GetAllowAnyCorsExemptHeaderForBrowser() const;
 
   mojo::PendingRemote<mojom::DevToolsObserver> GetDevToolsObserver(
diff --git a/services/network/network_service.cc b/services/network/network_service.cc
index efa5f97ab06ab..75ffd67870153 100644
--- a/services/network/network_service.cc
+++ b/services/network/network_service.cc
@@ -12,6 +12,7 @@
 
 #include "base/check.h"
 #include "base/check_op.h"
+#include "base/containers/contains.h"
 #include "base/debug/crash_logging.h"
 #include "base/debug/dump_without_crashing.h"
 #include "base/environment.h"
@@ -663,6 +664,33 @@ void NetworkService::SetEncryptionKey(const std::string& encryption_key) {
   OSCrypt::SetRawEncryptionKey(encryption_key);
 }
 
+void NetworkService::AddAllowedRequestInitiatorForPlugin(
+    int32_t process_id,
+    const url::Origin& allowed_request_initiator) {
+  DCHECK_NE(mojom::kBrowserProcessId, process_id);
+  std::map<int, std::set<url::Origin>>& map = plugin_origins_;
+  map[process_id].insert(allowed_request_initiator);
+}
+
+void NetworkService::RemoveSecurityExceptionsForPlugin(int32_t process_id) {
+  DCHECK_NE(mojom::kBrowserProcessId, process_id);
+
+  std::map<int, std::set<url::Origin>>& map = plugin_origins_;
+  map.erase(process_id);
+}
+
+bool NetworkService::IsInitiatorAllowedForPlugin(
+    int process_id,
+    const url::Origin& request_initiator) {
+  const std::map<int, std::set<url::Origin>>& map = plugin_origins_;
+  const auto it = map.find(process_id);
+  if (it == map.end())
+    return false;
+
+  const std::set<url::Origin>& allowed_origins = it->second;
+  return base::Contains(allowed_origins, request_initiator);
+}
+
 void NetworkService::OnMemoryPressure(
     base::MemoryPressureListener::MemoryPressureLevel memory_pressure_level) {
   base::MemoryPressureListener::NotifyMemoryPressure(memory_pressure_level);
diff --git a/services/network/network_service.h b/services/network/network_service.h
index cdaa7ed6cae59..e851bce443253 100644
--- a/services/network/network_service.h
+++ b/services/network/network_service.h
@@ -176,6 +176,10 @@ class COMPONENT_EXPORT(NETWORK_SERVICE) NetworkService
   void OnTrustStoreChanged() override;
   void OnClientCertStoreChanged() override;
   void SetEncryptionKey(const std::string& encryption_key) override;
+  void AddAllowedRequestInitiatorForPlugin(
+      int32_t process_id,
+      const url::Origin& allowed_request_initiator) override;
+  void RemoveSecurityExceptionsForPlugin(int32_t process_id) override;
   void OnMemoryPressure(base::MemoryPressureListener::MemoryPressureLevel
                             memory_pressure_level) override;
   void OnPeerToPeerConnectionsCountChange(uint32_t count) override;
@@ -222,6 +226,9 @@ class COMPONENT_EXPORT(NETWORK_SERVICE) NetworkService
   bool quic_disabled() const { return quic_disabled_; }
   bool HasRawHeadersAccess(int32_t process_id, const GURL& resource_url) const;
 
+  bool IsInitiatorAllowedForPlugin(int process_id,
+                                   const url::Origin& request_initiator);
+
   net::NetworkQualityEstimator* network_quality_estimator() {
     return network_quality_estimator_manager_->GetNetworkQualityEstimator();
   }
@@ -421,6 +428,11 @@ class COMPONENT_EXPORT(NETWORK_SERVICE) NetworkService
 
   base::Time pins_list_update_time_;
 
+  // Map from a renderer process id, to the set of plugin origins embedded by
+  // that renderer process (the renderer will proxy requests from PPAPI - such
+  // requests should have their initiator origin within the set stored here).
+  std::map<int, std::set<url::Origin>> plugin_origins_;
+
   bool data_use_updates_enabled_ = false;
 
   // This is used only in tests. It avoids leaky SystemDnsConfigChangeNotifiers
diff --git a/services/network/public/cpp/initiator_lock_compatibility.h b/services/network/public/cpp/initiator_lock_compatibility.h
index d9e0c8024fa03..439e9e7eaf50c 100644
--- a/services/network/public/cpp/initiator_lock_compatibility.h
+++ b/services/network/public/cpp/initiator_lock_compatibility.h
@@ -40,7 +40,10 @@ enum class InitiatorLockCompatibility {
   // - HTML Imports (see https://crbug.com/871827#c9).
   kIncorrectLock = 4,
 
-  kMaxValue = kIncorrectLock
+  // Covered by AddAllowedRequestInitiatorForPlugin.
+  kAllowedRequestInitiatorForPlugin = 7,
+
+  kMaxValue = kAllowedRequestInitiatorForPlugin,
 };
 
 // Verifies if |request.request_initiator| matches
diff --git a/services/network/public/mojom/network_service.mojom b/services/network/public/mojom/network_service.mojom
index 043c64e6d58d0..e12252c57e5fc 100644
--- a/services/network/public/mojom/network_service.mojom
+++ b/services/network/public/mojom/network_service.mojom
@@ -301,6 +301,19 @@ interface NetworkService {
   // Send the encryption key to the network service to use for AES encryption.
   SetEncryptionKey(mojo_base.mojom.ByteString encryption_key);
 
+  // Notifies |request_initiator_origin_lock| enforcement code that |process_id|
+  // is proxying requests on behalf of a plugin from
+  // |allowed_request_initiator| origin.
+  //
+  // TODO(lukasza, kmoon): https://crbug.com/702993: Remove the code here once
+  // PDF support doesn't depend on PPAPI anymore.
+  AddAllowedRequestInitiatorForPlugin(
+      int32 process_id,
+      url.mojom.Origin allowed_request_initiator);
+
+  // Reverts AddAllowedRequestInitiatorForPlugin.
+  RemoveSecurityExceptionsForPlugin(int32 process_id);
+
   // Called when the system is low on memory.
   OnMemoryPressure(
       mojo_base.mojom.MemoryPressureLevel memory_pressure_level);
diff --git a/services/network/url_loader_unittest.cc b/services/network/url_loader_unittest.cc
index 41658351e994b..a6f87897e5740 100644
--- a/services/network/url_loader_unittest.cc
+++ b/services/network/url_loader_unittest.cc
@@ -4172,6 +4172,46 @@ TEST_F(URLLoaderTest, HttpAuthResponseHeadersAvailable) {
   EXPECT_EQ(auth_required_headers->response_code(), 401);
 }
 
+// This simulates a renderer that _pretends_ to be proxying requests for PDF
+// plugin (when browser didn't _actually_ confirm that Flash or PDF are hosted
+// by the given process via AddAllowedRequestInitiatorForPlugin).  We should
+// still apply CORB in this case.
+TEST_F(URLLoaderTest, CorbEffectiveWithNoCorsWhenNoActualPlugin) {
+  int kResourceType = 1;
+  ResourceRequest request =
+      CreateResourceRequest("GET", test_server()->GetURL("/hello.html"));
+  request.resource_type = kResourceType;
+  request.mode = mojom::RequestMode::kNoCors;
+  request.request_initiator = url::Origin::Create(GURL("http://foo.com/"));
+
+  base::RunLoop delete_run_loop;
+  mojo::PendingRemote<mojom::URLLoader> loader;
+  std::unique_ptr<URLLoader> url_loader;
+  context().mutable_factory_params().process_id = 234;
+  // No call to NetworkService::AddAllowedRequestInitiatorForPlugin - this is
+  // what we primarily want to cover in this test.
+  url_loader = std::make_unique<URLLoader>(
+      context(), DeleteLoaderCallback(&delete_run_loop, &url_loader),
+      loader.InitWithNewPipeAndPassReceiver(), 0, request,
+      client()->CreateRemote(), nullptr /* sync_url_loader_client */,
+      TRAFFIC_ANNOTATION_FOR_TESTS, 0 /* request_id */,
+      0 /* keepalive_request_size */, nullptr, nullptr /* trust_token_helper */,
+      mojo::NullRemote() /* cookie_observer */,
+      mojo::NullRemote() /* url_loader_network_observer */,
+      /*devtools_observer=*/mojo::NullRemote(),
+      /*accept_ch_frame_observer=*/mojo::NullRemote());
+
+  client()->RunUntilResponseBodyArrived();
+  std::string body = ReadBody();
+
+  client()->RunUntilComplete();
+
+  delete_run_loop.Run();
+
+  // The request body should be blocked by CORB.
+  ASSERT_EQ(std::string(), body);
+}
+
 // Make sure the client can't call FollowRedirect if there's no pending
 // redirect.
 TEST_F(URLLoaderTest, FollowRedirectTwice) {
diff --git a/services/network/prefetch_matching_url_loader_factory.cc b/services/network/prefetch_matching_url_loader_factory.cc
index f603d5c7ff6ab..eec25c544c579 100644
--- a/services/network/prefetch_matching_url_loader_factory.cc
+++ b/services/network/prefetch_matching_url_loader_factory.cc
@@ -194,6 +194,7 @@ bool PrefetchMatchingURLLoaderFactory::IsRequestSafeForMatching(
       return false;
 
     case InitiatorLockCompatibility::kIncorrectLock:
+    case InitiatorLockCompatibility::kAllowedRequestInitiatorForPlugin:
       // Requests from the renderer need to always specify a correct initiator.
       mojo::ReportBadMessage(
           "CorsURLLoaderFactory: lock VS initiator mismatch");

diff --git a/components/nacl/browser/nacl_process_host.cc b/components/nacl/browser/nacl_process_host.cc
index 3688fada5a03b..00d3c9cf54a0e 100644
--- a/components/nacl/browser/nacl_process_host.cc
+++ b/components/nacl/browser/nacl_process_host.cc
@@ -62,6 +62,7 @@
 #include "ppapi/host/host_factory.h"
 #include "ppapi/host/ppapi_host.h"
 #include "ppapi/proxy/ppapi_messages.h"
+#include "ppapi/shared_impl/ppapi_constants.h"
 #include "ppapi/shared_impl/ppapi_nacl_plugin_args.h"
 #include "sandbox/policy/mojom/sandbox.mojom.h"
 #include "sandbox/policy/switches.h"
diff --git a/content/browser/network_service_restart_browsertest.cc b/content/browser/network_service_restart_browsertest.cc
index a53c0176256ba..8ff5cd9e7430e 100644
--- a/content/browser/network_service_restart_browsertest.cc
+++ b/content/browser/network_service_restart_browsertest.cc
@@ -62,6 +62,10 @@
 #include "third_party/blink/public/common/features.h"
 #include "third_party/blink/public/common/service_worker/embedded_worker_status.h"
 
+#if BUILDFLAG(ENABLE_PLUGINS)
+#include "content/public/test/ppapi_test_utils.h"
+#endif
+
 namespace content {
 
 namespace {
@@ -136,6 +140,12 @@ class NetworkServiceRestartBrowserTest : public ContentBrowserTest {
   }
 
   void SetUpCommandLine(base::CommandLine* command_line) override {
+#if BUILDFLAG(ENABLE_PLUGINS)
+    // TODO(lukasza, kmoon): https://crbug.com/702993: Remove this dependency
+    // (and //ppapi/tests/corb_test_plugin.cc + BUILD.gn dependencies) once
+    // PDF support doesn't depend on PPAPI anymore.
+    ASSERT_TRUE(ppapi::RegisterCorbTestPlugin(command_line));
+#endif
     NetworkServiceRestartBrowserTest::SetUpCommandLine(command_line);
     command_line->AppendSwitchASCII(
         network::switches::kUseRelatedWebsiteSet,
@@ -1002,6 +1012,96 @@ IN_PROC_BROWSER_TEST_F(NetworkServiceRestartBrowserTest, Cookies) {
   EXPECT_EQ("foo=bar", EvalJs(web_contents, "document.cookie;"));
 }
 
+#if BUILDFLAG(ENABLE_PLUGINS)
+// Make sure that "trusted" plugins continue to be able to issue requests that
+// are cross-origin (wrt the host frame) after a network process crash:
+// - html frame: main-frame.com/title1.html
+// \-- plugin document: cross.origin.com/.../js.txt (`plugin_document_url`)
+//   \-- request from plugin: cross.origin.com/.../js.txt
+// This mimics the behavior of PDFs, which only issue requests for the plugin
+// document (e.q. network::ResourceRequest::request_initiator is same-origin wrt
+// ResourceRequest::url).
+//
+// This primarily verifies that OnNetworkServiceCrashRestorePluginExceptions in
+// render_process_host_impl.cc refreshes AddAllowedRequestInitiatorForPlugin
+// data after a NetworkService crash.
+//
+// See also https://crbug.com/874515 and https://crbug.com/846339.
+//
+// TODO(lukasza, kmoon): https://crbug.com/702993: Remove this test once PDF
+// support doesn't depend on PPAPI anymore.
+IN_PROC_BROWSER_TEST_F(NetworkServiceRestartBrowserTest, Plugin) {
+  if (IsInProcessNetworkService())
+    return;
+  auto* web_contents = shell()->web_contents();
+  ASSERT_TRUE(NavigateToURL(
+      web_contents,
+      embedded_test_server()->GetURL("main.frame.com", "/title1.html")));
+
+  // Load cross-origin document into the test plugin (see
+  // ppapi::RegisterCorbTestPlugin).
+  //
+  // The document has to be a MIME type that CORB will allow (such as
+  // javascript) - it cannot be a pdf or json, because these would be blocked by
+  // CORB (the real PDF plugin works because the plugin is hosted in a Chrome
+  // Extension where CORB is turned off).
+  GURL plugin_document_url = embedded_test_server()->GetURL(
+      "cross.origin.com", "/site_isolation/js.txt");
+  const char kLoadingScriptTemplate[] = R"(
+      var obj = document.createElement('object');
+      obj.id = 'plugin';
+      obj.data = $1;
+      obj.type = 'application/x-fake-pdf-for-testing';
+      obj.width = 400;
+      obj.height = 400;
+
+      document.body.appendChild(obj);
+  )";
+  EXPECT_FALSE(
+      web_contents->GetMainFrame()->GetLastCommittedOrigin().IsSameOriginWith(
+          url::Origin::Create(plugin_document_url)));
+  ASSERT_TRUE(ExecJs(web_contents,
+                     JsReplace(kLoadingScriptTemplate, plugin_document_url)));
+
+  // Ask the plugin to re-request the document URL (similarly to what the PDF
+  // plugin does to get chunks of linearized PDFs).
+  const char kFetchScriptTemplate[] = R"(
+      new Promise(function (resolve, reject) {
+          var obj = document.getElementById('plugin');
+          function callback(event) {
+              // Ignore plugin messages unrelated to requestUrl.
+              if (!event.data.startsWith('requestUrl: '))
+                return;
+
+              obj.removeEventListener('message', callback);
+              resolve('msg-from-plugin: ' + event.data);
+          };
+          obj.addEventListener('message', callback);
+          obj.postMessage('requestUrl: ' + $1);
+      });
+  )";
+  std::string fetch_script =
+      JsReplace(kFetchScriptTemplate, plugin_document_url);
+  ASSERT_EQ(
+      "msg-from-plugin: requestUrl: RESPONSE BODY: "
+      "var j = 0; document.write(j);\n",
+      EvalJs(web_contents, fetch_script));
+
+  // Crash the Network Service process and wait until host frame's
+  // URLLoaderFactory has been refreshed.
+  SimulateNetworkServiceCrash();
+  main_frame()->FlushNetworkAndNavigationInterfacesForTesting();
+
+  // Try the fetch again - it should still work (i.e. the mechanism for relaxing
+  // request_initiator_origin_lock enforcement should be resilient to network
+  // process crashes).
+  ASSERT_EQ(
+      "msg-from-plugin: requestUrl: RESPONSE BODY: "
+      "var j = 0; document.write(j);\n",
+      EvalJs(web_contents, fetch_script));
+}
+#endif
+
 // TODO(crbug.com/41423903): Fix deadlock on process startup on Android.
 #if BUILDFLAG(IS_ANDROID)
 IN_PROC_BROWSER_TEST_F(NetworkServiceRestartBrowserTest,
diff --git a/content/browser/plugin_service_impl.cc b/content/browser/plugin_service_impl.cc
index 282415706e698..8074a845d761f 100644
--- a/content/browser/plugin_service_impl.cc
+++ b/content/browser/plugin_service_impl.cc
@@ -149,6 +149,39 @@ PpapiPluginProcessHost* PluginServiceImpl::FindOrStartPpapiPluginProcess(
     return nullptr;
   }
 
+  if (info->permissions & ppapi::PERMISSION_PDF) {
+    // Extra assertions for the PDF plugin.  These assertions do not apply to
+    // the test plugin.
+    if (0 == (info->permissions & ppapi::PERMISSION_TESTING)) {
+      // We want to limit ability to bypass |request_initiator_origin_lock| to
+      // trustworthy renderers.  PDF plugin is okay, because it is always hosted
+      // by the PDF extension (mhjfbmdgcfjbbpaeojofohoefgiehjai) or
+      // chrome://print, both of which we assume are trustworthy (the extension
+      // process can also host other extensions, but this is okay).
+      //
+      // The CHECKs below help verify that |render_process_id| does not host
+      // web-controlled content.  This is a defense-in-depth for verifying that
+      // ShouldAllowPluginCreation called above is doing the right thing.
+      auto* policy = ChildProcessSecurityPolicyImpl::GetInstance();
+      ProcessLock renderer_lock = policy->GetProcessLock(render_process_id);
+      CHECK(!renderer_lock.matches_scheme(url::kHttpScheme) &&
+            !renderer_lock.matches_scheme(url::kHttpsScheme));
+      CHECK(embedder_origin.scheme() != url::kHttpScheme);
+      CHECK(embedder_origin.scheme() != url::kHttpsScheme);
+      CHECK(!embedder_origin.opaque());
+    }
+
+    // In some scenarios, the PDF plugin can issue fetch requests that will need
+    // to be proxied by |render_process_id| - such proxying needs to bypass
+    // CORB. See also https://crbug.com/1027173.
+    //
+    // TODO(lukasza, kmoon): https://crbug.com/702993: Remove the code here once
+    // PDF support doesn't depend on PPAPI anymore.
+    DCHECK(origin_lock.has_value());
+    RenderProcessHostImpl::AddAllowedRequestInitiatorForPlugin(
+        render_process_id, origin_lock.value());
+  }
+
   PpapiPluginProcessHost* plugin_host =
       FindPpapiPluginProcess(plugin_path, profile_data_directory, origin_lock);
   if (plugin_host)
diff --git a/content/public/test/ppapi_test_utils.cc b/content/public/test/ppapi_test_utils.cc
index d48fb5ef9de27..155905857e7ce 100644
--- a/content/public/test/ppapi_test_utils.cc
+++ b/content/public/test/ppapi_test_utils.cc
@@ -16,6 +16,7 @@
 #include "content/browser/renderer_host/pepper/pepper_udp_socket_message_filter.h"
 #include "content/public/common/content_constants.h"
 #include "content/public/common/content_switches.h"
+#include "ppapi/shared_impl/ppapi_constants.h"
 #include "ppapi/shared_impl/ppapi_switches.h"
 
 using CharType = base::FilePath::CharType;
@@ -71,6 +72,20 @@ bool RegisterPluginWithDefaultMimeType(
   return RegisterPlugins(command_line, plugins);
 }
 
+bool RegisterFakePdfPluginLibrary(base::CommandLine* command_line,
+                                  const StringType& library_name) {
+  std::vector<PluginInfo> plugins;
+  // Register a fake PDF plugin with 100.0 version (to avoid outdated checks).
+  base::FilePath::StringType fake_pdf_parameter =
+      base::FilePath::FromUTF8Unsafe(std::string("#") + "Fake PDF" +
+                                     "#Description#100.0")
+          .value();
+  plugins.push_back(
+      PluginInfo(library_name, fake_pdf_parameter,
+                 FILE_PATH_LITERAL("application/x-fake-pdf-for-testing")));
+  return RegisterPlugins(command_line, plugins);
+}
+
 }  // namespace
 
 bool RegisterTestPlugin(base::CommandLine* command_line) {
@@ -92,6 +107,12 @@ bool RegisterTestPluginWithExtraParameters(
                                            extra_registration_parameters);
 }
 
+bool RegisterCorbTestPlugin(base::CommandLine* command_line) {
+  StringType library_name =
+      base::FilePath::FromUTF8Unsafe(ppapi::kCorbTestPluginName).value();
+  return RegisterFakePdfPluginLibrary(command_line, library_name);
+}
+
 bool RegisterBlinkTestPlugin(base::CommandLine* command_line) {
 #if BUILDFLAG(IS_WIN)
   static const CharType kPluginLibrary[] = L"blink_test_plugin.dll";
diff --git a/content/public/test/ppapi_test_utils.h b/content/public/test/ppapi_test_utils.h
index 549c84fc92572..bdaeebaa46f03 100644
--- a/content/public/test/ppapi_test_utils.h
+++ b/content/public/test/ppapi_test_utils.h
@@ -35,6 +35,9 @@ namespace ppapi {
     base::CommandLine* command_line,
     const base::FilePath::StringType& extra_registration_parameters);
 
+// Registers the PDF-imitating CORB-testing plugin.
+[[nodiscard]] bool RegisterCorbTestPlugin(base::CommandLine* command_line);
+
 // Registers the Blink test plugin to application/x-blink-test-plugin.
 [[nodiscard]] bool RegisterBlinkTestPlugin(base::CommandLine* command_line);
 
diff --git a/content/test/BUILD.gn b/content/test/BUILD.gn
index 6d45e7bba5822..0b31542102fb9 100644
--- a/content/test/BUILD.gn
+++ b/content/test/BUILD.gn
@@ -1540,7 +1540,10 @@ test("content_browsertests") {
       "//ppapi/proxy:test_support",
       "//ppapi/shared_impl:test_support",
     ]
-    data_deps += [ "//ppapi:ppapi_tests" ]
+    data_deps += [
+      "//ppapi:corb_test_plugin",
+      "//ppapi:ppapi_tests",
+    ]
     data += [
       "//ppapi/tests/test_case.html",
       "//ppapi/tests/test_page.css",
diff --git a/ppapi/BUILD.gn b/ppapi/BUILD.gn
index bfa92ed7904eb..8f1fced730a03 100644
--- a/ppapi/BUILD.gn
+++ b/ppapi/BUILD.gn
@@ -219,6 +219,31 @@ target(ppapi_tests_target_type, "ppapi_tests") {
   deps = [ ":ppapi_tests_sources" ]
 }
 
+# Test plugin for Cross-Origin Read Blocking.
+# See also ppapi::RegisterCorbTestPlugin.
+source_set("corb_test_plugin_sources") {
+  sources = [
+    "tests/corb_test_plugin.cc",
+    "tests/test_utils.cc",
+    "tests/test_utils.h",
+  ]
+
+  deps = [
+    "//ppapi/cpp",
+    "//ppapi/shared_impl",
+  ]
+}
+
+if (!is_mac) {
+  shared_library("corb_test_plugin") {
+    deps = [ ":corb_test_plugin_sources" ]
+  }
+} else {
+  mac_plugin_bundle("corb_test_plugin") {
+    deps = [ ":corb_test_plugin_sources" ]
+  }
+}
+
 source_set("blink_deprecated_test_plugin_sources") {
   sources = [ "tests/blink_deprecated_test_plugin.cc" ]
 
diff --git a/ppapi/proxy/plugin_globals.cc b/ppapi/proxy/plugin_globals.cc
index 6cba804bef9b8..a5942a90596d1 100644
--- a/ppapi/proxy/plugin_globals.cc
+++ b/ppapi/proxy/plugin_globals.cc
@@ -20,6 +20,7 @@
 #include "ppapi/proxy/ppb_message_loop_proxy.h"
 #include "ppapi/proxy/resource_reply_thread_registrar.h"
 #include "ppapi/proxy/udp_socket_filter.h"
+#include "ppapi/shared_impl/ppapi_constants.h"
 #include "ppapi/shared_impl/proxy_lock.h"
 #include "ppapi/thunk/enter.h"
 
diff --git a/ppapi/shared_impl/BUILD.gn b/ppapi/shared_impl/BUILD.gn
index 301d1e6cdc755..2931e6557869b 100644
--- a/ppapi/shared_impl/BUILD.gn
+++ b/ppapi/shared_impl/BUILD.gn
@@ -139,6 +139,7 @@ component("shared_impl") {
     "media_stream_video_track_shared.h",
     "platform_file.cc",
     "platform_file.h",
+    "ppapi_constants.h",
     "ppapi_nacl_plugin_args.cc",
     "ppapi_nacl_plugin_args.h",
     "ppapi_permissions.cc",
diff --git a/ppapi/shared_impl/ppapi_constants.h b/ppapi/shared_impl/ppapi_constants.h
new file mode 100644
index 0000000000000..528dfe220bf24
--- /dev/null
+++ b/ppapi/shared_impl/ppapi_constants.h
@@ -0,0 +1,23 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef PPAPI_SHARED_IMPL_PPAPI_CONSTANTS_H_
+#define PPAPI_SHARED_IMPL_PPAPI_CONSTANTS_H_
+
+#include "build/build_config.h"
+#include "ppapi/shared_impl/ppapi_shared_export.h"
+
+namespace ppapi {
+
+#if BUILDFLAG(IS_WIN)
+const char kCorbTestPluginName[] = "corb_test_plugin.dll";
+#elif BUILDFLAG(IS_MAC)
+const char kCorbTestPluginName[] = "corb_test_plugin.plugin";
+#elif BUILDFLAG(IS_POSIX)
+const char kCorbTestPluginName[] = "libcorb_test_plugin.so";
+#endif
+
+}  // namespace ppapi
+
+#endif  // PPAPI_SHARED_IMPL_PPAPI_CONSTANTS_H_
diff --git a/ppapi/shared_impl/ppapi_nacl_plugin_args.cc b/ppapi/shared_impl/ppapi_nacl_plugin_args.cc
index 92df690ceb3a3..c30470b14cda7 100644
--- a/ppapi/shared_impl/ppapi_nacl_plugin_args.cc
+++ b/ppapi/shared_impl/ppapi_nacl_plugin_args.cc
@@ -2,6 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "ppapi/shared_impl/ppapi_constants.h"
 #include "ppapi/shared_impl/ppapi_nacl_plugin_args.h"
 
 namespace ppapi {
diff --git a/ppapi/tests/corb_test_plugin.cc b/ppapi/tests/corb_test_plugin.cc
new file mode 100644
index 0000000000000..a23597b91c27e
--- /dev/null
+++ b/ppapi/tests/corb_test_plugin.cc
@@ -0,0 +1,93 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <stdint.h>
+
+#include <sstream>
+
+#include "ppapi/c/trusted/ppb_url_loader_trusted.h"
+#include "ppapi/cpp/instance.h"
+#include "ppapi/cpp/module.h"
+#include "ppapi/cpp/url_loader.h"
+#include "ppapi/cpp/url_request_info.h"
+#include "ppapi/tests/test_utils.h"
+
+// Windows defines 'PostMessage', so we have to undef it.
+#ifdef PostMessage
+#undef PostMessage
+#endif
+
+// This is a simple C++ Pepper plugin that enables some NetworkService/CORB
+// tests (e.g. NetworkServiceRestartBrowserTest.Plugin).
+class CorbTestInstance : public pp::Instance {
+ public:
+  explicit CorbTestInstance(PP_Instance instance) : pp::Instance(instance) {}
+  ~CorbTestInstance() override {}
+
+  void HandleMessage(const pp::Var& message_data) override {
+    if (!message_data.is_string())
+      return;
+
+    std::string msg = message_data.AsString();
+    const std::string kRequestUrlMsgPrefix("requestUrl: ");
+    if (msg.substr(0, kRequestUrlMsgPrefix.size()) == kRequestUrlMsgPrefix) {
+      // This is for NetworkServiceRestartBrowserTest.Plugin test.
+      std::string url = msg.substr(kRequestUrlMsgPrefix.size());
+      RequestURLAndPostResponseBody(url);
+    }
+  }
+
+ private:
+  void RequestURLAndPostResponseBody(const std::string& url) {
+    pp::URLLoader loader(this);
+
+    const PPB_URLLoaderTrusted* url_loader_trusted_interface = nullptr;
+    url_loader_trusted_interface = static_cast<const PPB_URLLoaderTrusted*>(
+        pp::Module::Get()->GetBrowserInterface(PPB_URLLOADERTRUSTED_INTERFACE));
+    url_loader_trusted_interface->GrantUniversalAccess(loader.pp_resource());
+
+    pp::URLRequestInfo request(this);
+    request.SetURL(url);
+    request.SetAllowCrossOriginRequests(true);
+
+    // Set the |request_initiator| in the same way as the PDF plugin.
+    //
+    // (The PDF plugin is currently the only plugin that depends on relaxing
+    // `request_initiator_origin_lock` enforcement via
+    // network::mojom::NetworkService::AddAllowedRequestInitiatorForPlugin.)
+    request.SetCustomReferrerURL(url);
+
+    std::ostringstream msg_builder;
+    std::string response_body;
+    int result = OpenURLRequest(this->pp_instance(), &loader, request,
+                                PP_OPTIONAL, &response_body);
+    if (result == PP_OK) {
+      msg_builder << "requestUrl: "
+                  << "RESPONSE BODY: " << response_body;
+    } else {
+      msg_builder << "requestUrl: "
+                  << "PPAPI ERROR: " << result;
+    }
+
+    PostMessage(pp::Var(msg_builder.str()));
+  }
+};
+
+class CorbTestModule : public pp::Module {
+ public:
+  CorbTestModule() : pp::Module() {}
+  virtual ~CorbTestModule() {}
+
+  virtual pp::Instance* CreateInstance(PP_Instance instance) {
+    return new CorbTestInstance(instance);
+  }
+};
+
+namespace pp {
+
+Module* CreateModule() {
+  return new CorbTestModule();
+}
+
+}  // namespace pp

diff --git a/chrome/browser/BUILD.gn b/chrome/browser/BUILD.gn
index 4bcd2c16b619e..8820ffa0458fa 100644
--- a/chrome/browser/BUILD.gn
+++ b/chrome/browser/BUILD.gn
@@ -5878,6 +5878,8 @@ static_library("browser") {
     sources += [
       "renderer_host/pepper/chrome_browser_pepper_host_factory.cc",
       "renderer_host/pepper/chrome_browser_pepper_host_factory.h",
+      "renderer_host/pepper/monitor_finder_mac.h",
+      "renderer_host/pepper/monitor_finder_mac.mm",
       "renderer_host/pepper/pepper_isolated_file_system_message_filter.cc",
       "renderer_host/pepper/pepper_isolated_file_system_message_filter.h",
     ]
diff --git a/chrome/browser/renderer_host/pepper/monitor_finder_mac.h b/chrome/browser/renderer_host/pepper/monitor_finder_mac.h
new file mode 100644
index 0000000000000..ce41bda864221
--- /dev/null
+++ b/chrome/browser/renderer_host/pepper/monitor_finder_mac.h
@@ -0,0 +1,48 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_RENDERER_HOST_PEPPER_MONITOR_FINDER_MAC_H_
+#define CHROME_BROWSER_RENDERER_HOST_PEPPER_MONITOR_FINDER_MAC_H_
+
+#include <ApplicationServices/ApplicationServices.h>
+#include <stdint.h>
+
+#include "base/macros.h"
+#include "base/memory/ref_counted.h"
+#include "base/synchronization/lock.h"
+
+// MonitorFinder maps a RenderFrameHost to the display ID on which the widget
+// is painting. This class operates on the IO thread while the RenderFrameHost
+// is on the UI thread, so the value returned by GetMonitor() may be 0 until
+// the information can be retrieved asynchronously.
+class MonitorFinder : public base::RefCountedThreadSafe<MonitorFinder> {
+ public:
+  MonitorFinder(int process_id, int render_frame_id);
+
+  // Gets the native display ID for the <process_id, render_frame_id> tuple.
+  int64_t GetMonitor();
+
+  // Checks if the given |monitor_id| represents a built-in display.
+  static bool IsMonitorBuiltIn(int64_t monitor_id);
+
+ private:
+  friend class base::RefCountedThreadSafe<MonitorFinder>;
+  ~MonitorFinder();
+
+  // Method run on the UI thread to get the display information.
+  void FetchMonitorFromWidget();
+
+  const int process_id_;
+  const int render_frame_id_;
+
+  base::Lock mutex_;  // Protects the two members below.
+  // Whether one request to FetchMonitorFromWidget() has been made already.
+  bool request_sent_;
+  // The native display ID for the RenderFrameHost.
+  CGDirectDisplayID display_id_;
+
+  DISALLOW_COPY_AND_ASSIGN(MonitorFinder);
+};
+
+#endif  // CHROME_BROWSER_RENDERER_HOST_PEPPER_MONITOR_FINDER_MAC_H_
diff --git a/chrome/browser/renderer_host/pepper/monitor_finder_mac.mm b/chrome/browser/renderer_host/pepper/monitor_finder_mac.mm
new file mode 100644
index 0000000000000..e64fbfcfb068b
--- /dev/null
+++ b/chrome/browser/renderer_host/pepper/monitor_finder_mac.mm
@@ -0,0 +1,58 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/renderer_host/pepper/monitor_finder_mac.h"
+
+#import <Cocoa/Cocoa.h>
+
+#include "base/bind.h"
+#include "content/public/browser/browser_task_traits.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/render_frame_host.h"
+
+MonitorFinder::MonitorFinder(int process_id, int render_frame_id)
+    : process_id_(process_id),
+      render_frame_id_(render_frame_id),
+      request_sent_(false),
+      display_id_(kCGNullDirectDisplay) {}
+
+MonitorFinder::~MonitorFinder() {}
+
+int64_t MonitorFinder::GetMonitor() {
+  {
+    // The plugin may call this method several times, so avoid spamming the UI
+    // thread with requests by only allowing one outstanding request at a time.
+    base::AutoLock lock(mutex_);
+    if (request_sent_)
+      return display_id_;
+    request_sent_ = true;
+  }
+
+  content::GetUIThreadTaskRunner({})->PostTask(
+      FROM_HERE, base::BindOnce(&MonitorFinder::FetchMonitorFromWidget, this));
+  return display_id_;
+}
+
+// static
+bool MonitorFinder::IsMonitorBuiltIn(int64_t display_id) {
+  return CGDisplayIsBuiltin(display_id);
+}
+
+void MonitorFinder::FetchMonitorFromWidget() {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  content::RenderFrameHost* rfh =
+      content::RenderFrameHost::FromID(process_id_, render_frame_id_);
+  if (!rfh)
+    return;
+
+  gfx::NativeView native_view = rfh->GetNativeView();
+  NSWindow* window = [native_view.GetNativeNSView() window];
+  NSScreen* screen = [window screen];
+  CGDirectDisplayID display_id =
+      [[[screen deviceDescription] objectForKey:@"NSScreenNumber"] intValue];
+
+  base::AutoLock lock(mutex_);
+  request_sent_ = false;
+  display_id_ = display_id;
+}

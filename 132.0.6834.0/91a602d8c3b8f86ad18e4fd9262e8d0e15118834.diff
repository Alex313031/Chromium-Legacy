diff --git a/chrome/browser/ui/pdf/chrome_pdf_document_helper_client.cc b/chrome/browser/ui/pdf/chrome_pdf_document_helper_client.cc
index 118c57c2b3d54..8e7c9c901e6da 100644
--- a/chrome/browser/ui/pdf/chrome_pdf_document_helper_client.cc
+++ b/chrome/browser/ui/pdf/chrome_pdf_document_helper_client.cc
@@ -9,10 +9,23 @@
 #include "content/public/browser/render_frame_host.h"
 #include "content/public/browser/web_contents.h"
 #include "extensions/browser/guest_view/mime_handler_view/mime_handler_view_guest.h"
+#include "ppapi/c/private/ppb_pdf.h"
 #include "pdf/pdf_features.h"
 
 namespace {
 
+// For the UpdateContentRestrictions() call below, ensure the enum values in
+// chrome/common/content_restriction.h and ppapi/c/private/ppb_pdf.h match.
+#define STATIC_ASSERT_ENUM(a, b)                            \
+  static_assert(static_cast<int>(a) == static_cast<int>(b), \
+                "mismatching enums: " #a)
+
+STATIC_ASSERT_ENUM(CONTENT_RESTRICTION_COPY, PP_CONTENT_RESTRICTION_COPY);
+STATIC_ASSERT_ENUM(CONTENT_RESTRICTION_CUT, PP_CONTENT_RESTRICTION_CUT);
+STATIC_ASSERT_ENUM(CONTENT_RESTRICTION_PASTE, PP_CONTENT_RESTRICTION_PASTE);
+STATIC_ASSERT_ENUM(CONTENT_RESTRICTION_PRINT, PP_CONTENT_RESTRICTION_PRINT);
+STATIC_ASSERT_ENUM(CONTENT_RESTRICTION_SAVE, PP_CONTENT_RESTRICTION_SAVE);
+
 content::WebContents* GetWebContentsToUse(
     content::RenderFrameHost* render_frame_host) {
   // If we're viewing the PDF in a MimeHandlerViewGuest, use its embedder
diff --git a/ppapi/BUILD.gn b/ppapi/BUILD.gn
index 8f1fced730a03..c2dab92d23385 100644
--- a/ppapi/BUILD.gn
+++ b/ppapi/BUILD.gn
@@ -177,6 +177,8 @@ source_set("ppapi_tests_sources") {
     "tests/test_file_chooser.h",
     "tests/test_net_address_private.cc",
     "tests/test_net_address_private.h",
+    "tests/test_pdf.cc",
+    "tests/test_pdf.h",
     "tests/test_tcp_socket_private_trusted.cc",
     "tests/test_tcp_socket_private_trusted.h",
     "tests/test_url_util.cc",
@@ -294,6 +296,7 @@ test("ppapi_unittests") {
     "proxy/mock_resource.cc",
     "proxy/mock_resource.h",
     "proxy/nacl_message_scanner_unittest.cc",
+    "proxy/pdf_resource_unittest.cc",
     "proxy/plugin_dispatcher_unittest.cc",
     "proxy/plugin_resource_tracker_unittest.cc",
     "proxy/plugin_var_tracker_unittest.cc",
diff --git a/ppapi/c/private/ppb_pdf.h b/ppapi/c/private/ppb_pdf.h
index ba173a706ee16..4199699476e58 100644
--- a/ppapi/c/private/ppb_pdf.h
+++ b/ppapi/c/private/ppb_pdf.h
@@ -5,13 +5,129 @@
 #ifndef PPAPI_C_PRIVATE_PPB_PDF_H_
 #define PPAPI_C_PRIVATE_PPB_PDF_H_
 
+#include <stdint.h>
+
+#include "ppapi/c/pp_bool.h"
 #include "ppapi/c/pp_instance.h"
+#include "ppapi/c/pp_point.h"
+#include "ppapi/c/pp_rect.h"
+#include "ppapi/c/pp_resource.h"
+#include "ppapi/c/pp_var.h"
+#include "ppapi/c/private/pp_private_font_charset.h"
 
 #define PPB_PDF_INTERFACE "PPB_PDF;1"
 
+typedef enum {
+  PP_PDFFEATURE_HIDPI = 0,
+  PP_PDFFEATURE_PRINTING = 1
+} PP_PDFFeature;
+
+typedef enum {
+  PP_CONTENT_RESTRICTION_COPY = 1 << 0,
+  PP_CONTENT_RESTRICTION_CUT = 1 << 1,
+  PP_CONTENT_RESTRICTION_PASTE = 1 << 2,
+  PP_CONTENT_RESTRICTION_PRINT = 1 << 3,
+  PP_CONTENT_RESTRICTION_SAVE = 1 << 4
+} PP_ContentRestriction;
+
+struct PP_PrivateFontFileDescription {
+  const char* face;
+  uint32_t weight;
+  bool italic;
+};
+
+struct PP_PrivateFindResult {
+  int start_index;
+  int length;
+};
+
 struct PPB_PDF {
+  // Returns a resource identifying a font file corresponding to the given font
+  // request after applying the browser-specific fallback.
+  //
+  // Currently Linux-only.
+  PP_Resource (*GetFontFileWithFallback)(
+      PP_Instance instance,
+      const struct PP_BrowserFont_Trusted_Description* description,
+      PP_PrivateFontCharset charset);
+
+  // Given a resource previously returned by GetFontFileWithFallback, returns
+  // a pointer to the requested font table. Linux only.
+  bool (*GetFontTableForPrivateFontFile)(PP_Resource font_file,
+                                         uint32_t table,
+                                         void* output,
+                                         uint32_t* output_length);
+
+  // Search the given string using ICU.  Use PPB_Core's MemFree on results when
+  // done.
+  void (*SearchString)(PP_Instance instance,
+                       const unsigned short* string,
+                       const unsigned short* term,
+                       bool case_sensitive,
+                       struct PP_PrivateFindResult** results,
+                       uint32_t* count);
+
+  // Since WebFrame doesn't know about PPAPI requests, it'll think the page has
+  // finished loading even if there are outstanding requests by the plugin.
+  // Take this out once WebFrame knows about requests by PPAPI plugins.
+  void (*DidStartLoading)(PP_Instance instance);
+  void (*DidStopLoading)(PP_Instance instance);
+
+  // Sets content restriction for a full-page plugin (i.e. can't copy/print).
+  // The value is a bitfield of PP_ContentRestriction enums.
+  void (*SetContentRestriction)(PP_Instance instance, int restrictions);
+
+  // Notifies the browser that the given action has been performed.
+  void (*UserMetricsRecordAction)(PP_Instance instance, struct PP_Var action);
+
+  // Notifies the browser that the PDF has an unsupported feature.
+  void (*HasUnsupportedFeature)(PP_Instance instance);
+
+  // Invoke SaveAs... dialog, similar to the right-click or wrench menu.
+  void (*SaveAs)(PP_Instance instance);
+
   // Invoke Print dialog for plugin.
   void (*Print)(PP_Instance instance);
+
+  PP_Bool(*IsFeatureEnabled)(PP_Instance instance, PP_PDFFeature feature);
+
+  // Sets the selected text of the plugin.
+  void(*SetSelectedText)(PP_Instance instance, const char* selected_text);
+
+  // Sets the link currently under the cursor.
+  void (*SetLinkUnderCursor)(PP_Instance instance, const char* url);
+
+  // Gets pointers to the mmap'd V8 snapshot file and its size.
+  // This is needed when loading V8's initial snapshot from an external file.
+  void (*GetV8ExternalSnapshotData)(PP_Instance instance,
+                                    const char** snapshot_data_out,
+                                    int* snapshot_size_out);
+
+  // Sends information about the PDF's URL and the embedder's URL.
+  void (*SetCrashData)(PP_Instance instance,
+                       const char* pdf_url,
+                       const char* top_level_url);
+
+  // Sets the current selection bounding edges.
+  void (*SelectionChanged)(PP_Instance instance,
+                           const struct PP_FloatPoint* left,
+                           int32_t left_height,
+                           const struct PP_FloatPoint* right,
+                           int32_t right_height);
+
+  // Sets whether the PDF viewer can handle save commands internally.
+  void (*SetPluginCanSave)(PP_Instance instance, bool can_save);
+
+  // Displays an alert dialog.
+  void (*ShowAlertDialog)(PP_Instance instance, const char* message);
+
+  // Displays a confirmation dialog. This method is synchronous.
+  bool (*ShowConfirmDialog)(PP_Instance instance, const char* message);
+
+  // Displays a prompt dialog. This method is synchronous.
+  struct PP_Var (*ShowPromptDialog)(PP_Instance instance,
+                                    const char* message,
+                                    const char* default_answer);
 };
 
 #endif  // PPAPI_C_PRIVATE_PPB_PDF_H_
diff --git a/ppapi/cpp/private/pdf.cc b/ppapi/cpp/private/pdf.cc
index 78d56dc466100..08494de118add 100644
--- a/ppapi/cpp/private/pdf.cc
+++ b/ppapi/cpp/private/pdf.cc
@@ -4,8 +4,11 @@
 
 #include "ppapi/cpp/private/pdf.h"
 
+#include "ppapi/c/trusted/ppb_browser_font_trusted.h"
+#include "ppapi/cpp/image_data.h"
 #include "ppapi/cpp/instance_handle.h"
 #include "ppapi/cpp/module_impl.h"
+#include "ppapi/cpp/var.h"
 
 namespace pp {
 
@@ -22,10 +25,184 @@ bool PDF::IsAvailable() {
   return has_interface<PPB_PDF>();
 }
 
+// static
+PP_Resource PDF::GetFontFileWithFallback(
+    const InstanceHandle& instance,
+    const PP_BrowserFont_Trusted_Description* description,
+    PP_PrivateFontCharset charset) {
+  if (has_interface<PPB_PDF>()) {
+    return get_interface<PPB_PDF>()->GetFontFileWithFallback(
+        instance.pp_instance(), description, charset);
+  }
+  return 0;
+}
+
+// static
+bool PDF::GetFontTableForPrivateFontFile(PP_Resource font_file,
+                                         uint32_t table,
+                                         void* output,
+                                         uint32_t* output_length) {
+  if (has_interface<PPB_PDF>()) {
+    return get_interface<PPB_PDF>()->GetFontTableForPrivateFontFile(font_file,
+        table, output, output_length);
+  }
+  return false;
+}
+
+// static
+void PDF::SearchString(const InstanceHandle& instance,
+                       const unsigned short* string,
+                       const unsigned short* term,
+                       bool case_sensitive,
+                       PP_PrivateFindResult** results,
+                       uint32_t* count) {
+  if (has_interface<PPB_PDF>()) {
+    get_interface<PPB_PDF>()->SearchString(instance.pp_instance(), string,
+        term, case_sensitive, results, count);
+  }
+}
+
+// static
+void PDF::DidStartLoading(const InstanceHandle& instance) {
+  if (has_interface<PPB_PDF>())
+    get_interface<PPB_PDF>()->DidStartLoading(instance.pp_instance());
+}
+
+// static
+void PDF::DidStopLoading(const InstanceHandle& instance) {
+  if (has_interface<PPB_PDF>())
+    get_interface<PPB_PDF>()->DidStopLoading(instance.pp_instance());
+}
+
+// static
+void PDF::SetContentRestriction(const InstanceHandle& instance,
+                                int restrictions) {
+  if (has_interface<PPB_PDF>()) {
+    get_interface<PPB_PDF>()->SetContentRestriction(instance.pp_instance(),
+                                                    restrictions);
+  }
+}
+
+// static
+void PDF::UserMetricsRecordAction(const InstanceHandle& instance,
+                                  const Var& action) {
+  if (has_interface<PPB_PDF>()) {
+    get_interface<PPB_PDF>()->UserMetricsRecordAction(instance.pp_instance(),
+                                                      action.pp_var());
+  }
+}
+
+// static
+void PDF::HasUnsupportedFeature(const InstanceHandle& instance) {
+  if (has_interface<PPB_PDF>())
+    get_interface<PPB_PDF>()->HasUnsupportedFeature(instance.pp_instance());
+}
+
+// static
+void PDF::ShowAlertDialog(const InstanceHandle& instance, const char* message) {
+  if (has_interface<PPB_PDF>())
+    get_interface<PPB_PDF>()->ShowAlertDialog(instance.pp_instance(), message);
+}
+
+// static
+bool PDF::ShowConfirmDialog(const InstanceHandle& instance,
+                            const char* message) {
+  if (has_interface<PPB_PDF>()) {
+    return get_interface<PPB_PDF>()->ShowConfirmDialog(instance.pp_instance(),
+                                                       message);
+  }
+  return false;
+}
+
+// static
+pp::Var PDF::ShowPromptDialog(const InstanceHandle& instance,
+                              const char* message,
+                              const char* default_answer) {
+  if (has_interface<PPB_PDF>()) {
+    return pp::Var(PASS_REF,
+                   get_interface<PPB_PDF>()->ShowPromptDialog(
+                       instance.pp_instance(), message, default_answer));
+  }
+  return pp::Var();
+}
+
+// static
+void PDF::SaveAs(const InstanceHandle& instance) {
+  if (has_interface<PPB_PDF>())
+    get_interface<PPB_PDF>()->SaveAs(instance.pp_instance());
+}
+
 // static
 void PDF::Print(const InstanceHandle& instance) {
   if (has_interface<PPB_PDF>())
     get_interface<PPB_PDF>()->Print(instance.pp_instance());
 }
 
+// static
+bool PDF::IsFeatureEnabled(const InstanceHandle& instance,
+                           PP_PDFFeature feature) {
+  if (has_interface<PPB_PDF>())
+    return PP_ToBool(get_interface<PPB_PDF>()->IsFeatureEnabled(
+        instance.pp_instance(), feature));
+  return false;
+}
+
+// static
+void PDF::SetSelectedText(const InstanceHandle& instance,
+                          const char* selected_text) {
+  if (has_interface<PPB_PDF>()) {
+    get_interface<PPB_PDF>()->SetSelectedText(instance.pp_instance(),
+                                              selected_text);
+  }
+}
+
+// static
+void PDF::SetLinkUnderCursor(const InstanceHandle& instance, const char* url) {
+  if (has_interface<PPB_PDF>())
+    get_interface<PPB_PDF>()->SetLinkUnderCursor(instance.pp_instance(), url);
+}
+
+// static
+void PDF::GetV8ExternalSnapshotData(const InstanceHandle& instance,
+                                    const char** snapshot_data_out,
+                                    int* snapshot_size_out) {
+  if (has_interface<PPB_PDF>()) {
+    get_interface<PPB_PDF>()->GetV8ExternalSnapshotData(
+        instance.pp_instance(), snapshot_data_out, snapshot_size_out);
+    return;
+  }
+  *snapshot_data_out = NULL;
+  *snapshot_size_out = 0;
+}
+
+// static
+void PDF::SetCrashData(const InstanceHandle& instance,
+                       const char* pdf_url,
+                       const char* top_level_url) {
+  if (has_interface<PPB_PDF>()) {
+    get_interface<PPB_PDF>()->SetCrashData(instance.pp_instance(), pdf_url,
+                                           top_level_url);
+  }
+}
+
+// static
+void PDF::SelectionChanged(const InstanceHandle& instance,
+                           const PP_FloatPoint& left,
+                           int32_t left_height,
+                           const PP_FloatPoint& right,
+                           int32_t right_height) {
+  if (has_interface<PPB_PDF>()) {
+    get_interface<PPB_PDF>()->SelectionChanged(
+        instance.pp_instance(), &left, left_height, &right, right_height);
+  }
+}
+
+// static
+void PDF::SetPluginCanSave(const InstanceHandle& instance, bool can_save) {
+  if (has_interface<PPB_PDF>()) {
+    get_interface<PPB_PDF>()->SetPluginCanSave(instance.pp_instance(),
+                                               can_save);
+  }
+}
+
 }  // namespace pp
diff --git a/ppapi/cpp/private/pdf.h b/ppapi/cpp/private/pdf.h
index d2074791700d8..2eb96aaf08802 100644
--- a/ppapi/cpp/private/pdf.h
+++ b/ppapi/cpp/private/pdf.h
@@ -9,16 +9,66 @@
 
 #include "ppapi/c/private/ppb_pdf.h"
 
+struct PP_BrowserFont_Trusted_Description;
+
 namespace pp {
 
 class InstanceHandle;
+class Var;
 
 class PDF {
  public:
   // Returns true if the required interface is available.
   static bool IsAvailable();
 
+  static PP_Resource GetFontFileWithFallback(
+      const InstanceHandle& instance,
+      const PP_BrowserFont_Trusted_Description* description,
+      PP_PrivateFontCharset charset);
+  static bool GetFontTableForPrivateFontFile(PP_Resource font_file,
+                                             uint32_t table,
+                                             void* output,
+                                             uint32_t* output_length);
+  static void SearchString(const InstanceHandle& instance,
+                           const unsigned short* string,
+                           const unsigned short* term,
+                           bool case_sensitive,
+                           PP_PrivateFindResult** results,
+                           uint32_t* count);
+  static void DidStartLoading(const InstanceHandle& instance);
+  static void DidStopLoading(const InstanceHandle& instance);
+  static void SetContentRestriction(const InstanceHandle& instance,
+                                    int restrictions);
+  static void UserMetricsRecordAction(const InstanceHandle& instance,
+                                      const Var& action);
+  static void HasUnsupportedFeature(const InstanceHandle& instance);
+  static void ShowAlertDialog(const InstanceHandle& instance,
+                              const char* message);
+  static bool ShowConfirmDialog(const InstanceHandle& instance,
+                                const char* message);
+  static pp::Var ShowPromptDialog(const InstanceHandle& instance,
+                                  const char* message,
+                                  const char* default_answer);
+  static void SaveAs(const InstanceHandle& instance);
   static void Print(const InstanceHandle& instance);
+  static bool IsFeatureEnabled(const InstanceHandle& instance,
+                               PP_PDFFeature feature);
+  static void SetSelectedText(const InstanceHandle& instance,
+                              const char* selected_text);
+  static void SetLinkUnderCursor(const InstanceHandle& instance,
+                                 const char* url);
+  static void GetV8ExternalSnapshotData(const InstanceHandle& instance,
+                                        const char** snapshot_data_out,
+                                        int* snapshot_size_out);
+  static void SetCrashData(const InstanceHandle& instance,
+                           const char* pdf_url,
+                           const char* top_level_url);
+  static void SelectionChanged(const InstanceHandle& instance,
+                               const PP_FloatPoint& left,
+                               int32_t left_height,
+                               const PP_FloatPoint& right,
+                               int32_t right_height);
+  static void SetPluginCanSave(const InstanceHandle& instance, bool can_save);
 };
 
 }  // namespace pp
diff --git a/ppapi/proxy/OWNERS b/ppapi/proxy/OWNERS
index c19effdcbd005..cf5f23a0b58c2 100644
--- a/ppapi/proxy/OWNERS
+++ b/ppapi/proxy/OWNERS
@@ -8,4 +8,5 @@ per-file *_param_traits*.*=set noparent
 per-file *_param_traits*.*=file://ipc/SECURITY_OWNERS
 
 per-file pdf_resource.*=thestig@chromium.org
+per-file pdf_resource_unittest.cc=thestig@chromium.org
 per-file ppp_pdf_proxy.*=thestig@chromium.org
diff --git a/ppapi/proxy/pdf_resource.cc b/ppapi/proxy/pdf_resource.cc
index d71cc4757758d..f2b9a2fce389d 100644
--- a/ppapi/proxy/pdf_resource.cc
+++ b/ppapi/proxy/pdf_resource.cc
@@ -4,14 +4,46 @@
 
 #include "ppapi/proxy/pdf_resource.h"
 
+#include <stddef.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <limits>
+#include <utility>
+#include <vector>
+
+#include "base/command_line.h"
+#include "base/debug/crash_logging.h"
+#include "base/metrics/histogram.h"
+#include "base/strings/utf_string_conversions.h"
+#include "gin/v8_initializer.h"
 #include "ppapi/c/pp_errors.h"
 #include "ppapi/c/private/ppb_pdf.h"
 #include "ppapi/proxy/plugin_globals.h"
 #include "ppapi/proxy/ppapi_messages.h"
+#include "ppapi/shared_impl/var.h"
+#include "third_party/icu/source/i18n/unicode/usearch.h"
 
 namespace ppapi {
 namespace proxy {
 
+namespace {
+
+// TODO(raymes): This is just copied from render_thread_impl.cc. We should have
+// generic code somewhere to get the locale in the plugin.
+std::string GetLocale() {
+  // The browser process should have passed the locale to the plugin via the
+  // --lang command line flag.
+  const base::CommandLine& parsed_command_line =
+      *base::CommandLine::ForCurrentProcess();
+  const std::string& lang = parsed_command_line.GetSwitchValueASCII("lang");
+  DCHECK(!lang.empty());
+  return lang;
+}
+
+}  // namespace
+
 PDFResource::PDFResource(Connection connection, PP_Instance instance)
     : PluginResource(connection, instance) {
   SendCreate(RENDERER, PpapiHostMsg_PDF_Create());
@@ -24,9 +56,169 @@ thunk::PPB_PDF_API* PDFResource::AsPPB_PDF_API() {
   return this;
 }
 
+void PDFResource::SearchString(const unsigned short* input_string,
+                               const unsigned short* input_term,
+                               bool case_sensitive,
+                               PP_PrivateFindResult** results,
+                               uint32_t* count) {
+  if (locale_.empty())
+    locale_ = GetLocale() + "@collation=search";
+
+  const UChar* string = reinterpret_cast<const UChar*>(input_string);
+  const UChar* term = reinterpret_cast<const UChar*>(input_term);
+
+  UErrorCode status = U_ZERO_ERROR;
+  UStringSearch* searcher =
+      usearch_open(term, -1, string, -1, locale_.c_str(), nullptr, &status);
+  DCHECK(U_SUCCESS(status)) << status;
+  UCollationStrength strength = case_sensitive ? UCOL_TERTIARY : UCOL_PRIMARY;
+
+  UCollator* collator = usearch_getCollator(searcher);
+  if (ucol_getStrength(collator) != strength) {
+    ucol_setStrength(collator, strength);
+    usearch_reset(searcher);
+  }
+
+  status = U_ZERO_ERROR;
+  int match_start = usearch_first(searcher, &status);
+  DCHECK(U_SUCCESS(status));
+
+  std::vector<PP_PrivateFindResult> pp_results;
+  while (match_start != USEARCH_DONE) {
+    int32_t matched_length = usearch_getMatchedLength(searcher);
+    PP_PrivateFindResult result;
+    result.start_index = match_start;
+    result.length = matched_length;
+    pp_results.push_back(result);
+    match_start = usearch_next(searcher, &status);
+    DCHECK(U_SUCCESS(status));
+  }
+
+  if (pp_results.empty() ||
+      pp_results.size() > std::numeric_limits<uint32_t>::max() ||
+      pp_results.size() > SIZE_MAX / sizeof(PP_PrivateFindResult)) {
+    *count = 0;
+    *results = nullptr;
+  } else {
+    *count = static_cast<uint32_t>(pp_results.size());
+    const size_t result_size = pp_results.size() * sizeof(PP_PrivateFindResult);
+    *results = reinterpret_cast<PP_PrivateFindResult*>(malloc(result_size));
+    memcpy(*results, &pp_results[0], result_size);
+  }
+
+  usearch_close(searcher);
+}
+
+void PDFResource::DidStartLoading() {
+  Post(RENDERER, PpapiHostMsg_PDF_DidStartLoading());
+}
+
+void PDFResource::DidStopLoading() {
+  Post(RENDERER, PpapiHostMsg_PDF_DidStopLoading());
+}
+
+void PDFResource::SetContentRestriction(int restrictions) {
+  Post(RENDERER, PpapiHostMsg_PDF_SetContentRestriction(restrictions));
+}
+
+void PDFResource::UserMetricsRecordAction(const PP_Var& action) {
+  scoped_refptr<ppapi::StringVar> action_str(
+      ppapi::StringVar::FromPPVar(action));
+  if (action_str.get()) {
+    Post(RENDERER,
+         PpapiHostMsg_PDF_UserMetricsRecordAction(action_str->value()));
+  }
+}
+
+void PDFResource::HasUnsupportedFeature() {
+  Post(RENDERER, PpapiHostMsg_PDF_HasUnsupportedFeature());
+}
+
 void PDFResource::Print() {
   Post(RENDERER, PpapiHostMsg_PDF_Print());
 }
 
+void PDFResource::ShowAlertDialog(const char* message) {
+  SyncCall<PpapiPluginMsg_PDF_ShowAlertDialogReply>(
+      RENDERER, PpapiHostMsg_PDF_ShowAlertDialog(message));
+}
+
+bool PDFResource::ShowConfirmDialog(const char* message) {
+  bool bool_result = false;
+  if (SyncCall<PpapiPluginMsg_PDF_ShowConfirmDialogReply>(
+          RENDERER, PpapiHostMsg_PDF_ShowConfirmDialog(message),
+          &bool_result) != PP_OK) {
+    return false;
+  }
+  return bool_result;
+}
+
+PP_Var PDFResource::ShowPromptDialog(const char* message,
+                                     const char* default_answer) {
+  std::string str_result;
+  if (SyncCall<PpapiPluginMsg_PDF_ShowPromptDialogReply>(
+          RENDERER, PpapiHostMsg_PDF_ShowPromptDialog(message, default_answer),
+          &str_result) != PP_OK) {
+    return PP_MakeUndefined();
+  }
+  return StringVar::StringToPPVar(str_result);
+}
+
+void PDFResource::SaveAs() {
+  Post(RENDERER, PpapiHostMsg_PDF_SaveAs());
+}
+
+PP_Bool PDFResource::IsFeatureEnabled(PP_PDFFeature feature) {
+  PP_Bool result = PP_FALSE;
+  switch (feature) {
+    case PP_PDFFEATURE_HIDPI:
+      result = PP_TRUE;
+      break;
+    case PP_PDFFEATURE_PRINTING:
+      // TODO(raymes): Use PrintRenderFrameHelper::IsPrintingEnabled.
+      result = PP_FALSE;
+      break;
+  }
+  return result;
+}
+
+void PDFResource::SetSelectedText(const char* selected_text) {
+  Post(RENDERER,
+       PpapiHostMsg_PDF_SetSelectedText(base::UTF8ToUTF16(selected_text)));
+}
+
+void PDFResource::SetLinkUnderCursor(const char* url) {
+  Post(RENDERER, PpapiHostMsg_PDF_SetLinkUnderCursor(url));
+}
+
+void PDFResource::GetV8ExternalSnapshotData(const char** snapshot_data_out,
+                                            int* snapshot_size_out) {
+  gin::V8Initializer::GetV8ExternalSnapshotData(snapshot_data_out,
+                                                snapshot_size_out);
+}
+
+void PDFResource::SetCrashData(const char* pdf_url, const char* top_level_url) {
+  if (pdf_url) {
+    static base::debug::CrashKeyString* subresource_url =
+        base::debug::AllocateCrashKeyString("subresource_url",
+                                            base::debug::CrashKeySize::Size256);
+    base::debug::SetCrashKeyString(subresource_url, pdf_url);
+  }
+  if (top_level_url)
+    PluginGlobals::Get()->SetActiveURL(top_level_url);
+}
+
+void PDFResource::SelectionChanged(const PP_FloatPoint& left,
+                                   int32_t left_height,
+                                   const PP_FloatPoint& right,
+                                   int32_t right_height) {
+  Post(RENDERER, PpapiHostMsg_PDF_SelectionChanged(left, left_height, right,
+                                                   right_height));
+}
+
+void PDFResource::SetPluginCanSave(bool can_save) {
+  Post(RENDERER, PpapiHostMsg_PDF_SetPluginCanSave(can_save));
+}
+
 }  // namespace proxy
 }  // namespace ppapi
diff --git a/ppapi/proxy/pdf_resource.h b/ppapi/proxy/pdf_resource.h
index 2575f5fbb9131..9d0c3948824c5 100644
--- a/ppapi/proxy/pdf_resource.h
+++ b/ppapi/proxy/pdf_resource.h
@@ -38,7 +38,33 @@ class PPAPI_PROXY_EXPORT PDFResource
   thunk::PPB_PDF_API* AsPPB_PDF_API() override;
 
   // PPB_PDF_API implementation.
+  void SearchString(const unsigned short* input_string,
+                    const unsigned short* input_term,
+                    bool case_sensitive,
+                    PP_PrivateFindResult** results,
+                    uint32_t* count) override;
+  void DidStartLoading() override;
+  void DidStopLoading() override;
+  void SetContentRestriction(int restrictions) override;
+  void UserMetricsRecordAction(const PP_Var& action) override;
+  void HasUnsupportedFeature() override;
   void Print() override;
+  void ShowAlertDialog(const char* messasge) override;
+  bool ShowConfirmDialog(const char* messasge) override;
+  PP_Var ShowPromptDialog(const char* messasge,
+                          const char* default_answer) override;
+  void SaveAs() override;
+  PP_Bool IsFeatureEnabled(PP_PDFFeature feature) override;
+  void SetSelectedText(const char* selected_text) override;
+  void SetLinkUnderCursor(const char* url) override;
+  void GetV8ExternalSnapshotData(const char** snapshot_data_out,
+                                 int* snapshot_size_out) override;
+  void SetCrashData(const char* pdf_url, const char* top_level_url) override;
+  void SelectionChanged(const PP_FloatPoint& left,
+                        int32_t left_height,
+                        const PP_FloatPoint& right,
+                        int32_t right_height) override;
+  void SetPluginCanSave(bool can_save) override;
 
  private:
   std::string locale_;
diff --git a/ppapi/proxy/pdf_resource_unittest.cc b/ppapi/proxy/pdf_resource_unittest.cc
new file mode 100644
index 0000000000000..f70149e84f4ab
--- /dev/null
+++ b/ppapi/proxy/pdf_resource_unittest.cc
@@ -0,0 +1,153 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <cstring>
+
+#include "base/strings/utf_string_conversions.h"
+#include "ppapi/c/dev/ppb_memory_dev.h"
+#include "ppapi/c/pp_errors.h"
+#include "ppapi/c/ppb_image_data.h"
+#include "ppapi/proxy/pdf_resource.h"
+#include "ppapi/proxy/ppapi_messages.h"
+#include "ppapi/proxy/ppapi_proxy_test.h"
+#include "ppapi/proxy/ppb_image_data_proxy.h"
+#include "ppapi/proxy/serialized_handle.h"
+#include "ppapi/shared_impl/proxy_lock.h"
+#include "ppapi/shared_impl/scoped_pp_var.h"
+#include "ppapi/shared_impl/var.h"
+#include "ppapi/thunk/thunk.h"
+
+namespace ppapi {
+namespace proxy {
+
+namespace {
+
+typedef PluginProxyTest PDFResourceTest;
+
+}  // namespace
+
+TEST_F(PDFResourceTest, SearchString) {
+  ProxyAutoLock lock;
+  // Instantiate a resource explicitly so we can specify the locale.
+  auto pdf_resource = base::MakeRefCounted<PDFResource>(
+      Connection(&sink(), &sink(), 0), pp_instance());
+  pdf_resource->SetLocaleForTest("en-US@collation=search");
+
+  std::u16string input;
+  std::u16string term;
+  base::UTF8ToUTF16("abcdefabcdef", 12, &input);
+  base::UTF8ToUTF16("bc", 2, &term);
+
+  PP_PrivateFindResult* results;
+  uint32_t count = 0;
+  pdf_resource->SearchString(
+      reinterpret_cast<const unsigned short*>(input.c_str()),
+      reinterpret_cast<const unsigned short*>(term.c_str()),
+      true,
+      &results,
+      &count);
+
+  ASSERT_EQ(2U, count);
+  ASSERT_EQ(1, results[0].start_index);
+  ASSERT_EQ(2, results[0].length);
+  ASSERT_EQ(7, results[1].start_index);
+  ASSERT_EQ(2, results[1].length);
+
+  const PPB_Memory_Dev* memory_iface = thunk::GetPPB_Memory_Dev_0_1_Thunk();
+  memory_iface->MemFree(results);
+}
+
+TEST_F(PDFResourceTest, DidStartLoading) {
+  const PPB_PDF* pdf_iface = thunk::GetPPB_PDF_Thunk();
+
+  pdf_iface->DidStartLoading(pp_instance());
+
+  ResourceMessageCallParams params;
+  IPC::Message msg;
+  ASSERT_TRUE(sink().GetFirstResourceCallMatching(
+      PpapiHostMsg_PDF_DidStartLoading::ID, &params, &msg));
+}
+
+TEST_F(PDFResourceTest, DidStopLoading) {
+  const PPB_PDF* pdf_iface = thunk::GetPPB_PDF_Thunk();
+
+  pdf_iface->DidStopLoading(pp_instance());
+
+  ResourceMessageCallParams params;
+  IPC::Message msg;
+  ASSERT_TRUE(sink().GetFirstResourceCallMatching(
+      PpapiHostMsg_PDF_DidStopLoading::ID, &params, &msg));
+}
+
+TEST_F(PDFResourceTest, SetContentRestriction) {
+  const PPB_PDF* pdf_iface = thunk::GetPPB_PDF_Thunk();
+
+  int restrictions = 5;
+  pdf_iface->SetContentRestriction(pp_instance(), restrictions);
+
+  ResourceMessageCallParams params;
+  IPC::Message msg;
+  ASSERT_TRUE(sink().GetFirstResourceCallMatching(
+      PpapiHostMsg_PDF_SetContentRestriction::ID, &params, &msg));
+}
+
+TEST_F(PDFResourceTest, HasUnsupportedFeature) {
+  const PPB_PDF* pdf_iface = thunk::GetPPB_PDF_Thunk();
+
+  pdf_iface->HasUnsupportedFeature(pp_instance());
+
+  ResourceMessageCallParams params;
+  IPC::Message msg;
+  ASSERT_TRUE(sink().GetFirstResourceCallMatching(
+      PpapiHostMsg_PDF_HasUnsupportedFeature::ID, &params, &msg));
+}
+
+TEST_F(PDFResourceTest, Print) {
+  const PPB_PDF* pdf_iface = thunk::GetPPB_PDF_Thunk();
+
+  pdf_iface->Print(pp_instance());
+
+  ResourceMessageCallParams params;
+  IPC::Message msg;
+  ASSERT_TRUE(sink().GetFirstResourceCallMatching(
+      PpapiHostMsg_PDF_Print::ID, &params, &msg));
+}
+
+TEST_F(PDFResourceTest, SaveAs) {
+  const PPB_PDF* pdf_iface = thunk::GetPPB_PDF_Thunk();
+
+  pdf_iface->SaveAs(pp_instance());
+
+  ResourceMessageCallParams params;
+  IPC::Message msg;
+  ASSERT_TRUE(sink().GetFirstResourceCallMatching(
+      PpapiHostMsg_PDF_SaveAs::ID, &params, &msg));
+}
+
+TEST_F(PDFResourceTest, SelectionChanged) {
+  const PPB_PDF* pdf_iface = thunk::GetPPB_PDF_Thunk();
+
+  PP_FloatPoint left = PP_MakeFloatPoint(0.0f, 0.0f);
+  PP_FloatPoint right = PP_MakeFloatPoint(1.0f, 1.0f);
+  pdf_iface->SelectionChanged(pp_instance(), &left, 0, &right, 0);
+
+  ResourceMessageCallParams params;
+  IPC::Message msg;
+  ASSERT_TRUE(sink().GetFirstResourceCallMatching(
+      PpapiHostMsg_PDF_SelectionChanged::ID, &params, &msg));
+}
+
+TEST_F(PDFResourceTest, SetPluginCanSave) {
+  const PPB_PDF* pdf_iface = thunk::GetPPB_PDF_Thunk();
+
+  pdf_iface->SetPluginCanSave(pp_instance(), true);
+
+  ResourceMessageCallParams params;
+  IPC::Message msg;
+  ASSERT_TRUE(sink().GetFirstResourceCallMatching(
+      PpapiHostMsg_PDF_SetPluginCanSave::ID, &params, &msg));
+}
+
+}  // namespace proxy
+}  // namespace ppapi
diff --git a/ppapi/proxy/ppapi_messages.h b/ppapi/proxy/ppapi_messages.h
index 1ef758910301a..17655cbb82d99 100644
--- a/ppapi/proxy/ppapi_messages.h
+++ b/ppapi/proxy/ppapi_messages.h
@@ -1826,9 +1826,70 @@ IPC_MESSAGE_CONTROL1(PpapiPluginMsg_FlashFontFile_GetFontTableReply,
 // Creates the PDF resource.
 IPC_MESSAGE_CONTROL0(PpapiHostMsg_PDF_Create)
 
+// Notifies the renderer that the PDF started loading.
+IPC_MESSAGE_CONTROL0(PpapiHostMsg_PDF_DidStartLoading)
+
+// Notifies the renderer that the PDF stopped loading.
+IPC_MESSAGE_CONTROL0(PpapiHostMsg_PDF_DidStopLoading)
+
+// Sets any restrictions on the PDF content.
+IPC_MESSAGE_CONTROL1(PpapiHostMsg_PDF_SetContentRestriction,
+                     int /* restrictions */)
+
+// Requests that the specified action be recorded with UMA.
+IPC_MESSAGE_CONTROL1(PpapiHostMsg_PDF_UserMetricsRecordAction,
+                     std::string /* action */)
+
+// Notifies the renderer that the current PDF uses an unsupported feature.
+IPC_MESSAGE_CONTROL0(PpapiHostMsg_PDF_HasUnsupportedFeature)
+
 // Notifies the renderer to print the current PDF.
 IPC_MESSAGE_CONTROL0(PpapiHostMsg_PDF_Print)
 
+// Notifies the renderer to display an alert dialog.
+IPC_MESSAGE_CONTROL1(PpapiHostMsg_PDF_ShowAlertDialog,
+                     std::string /* message */)
+// Reply from the renderer that the alert has been acknowledged.
+IPC_MESSAGE_CONTROL0(PpapiPluginMsg_PDF_ShowAlertDialogReply)
+
+// Notifies the renderer to display a confirmation dialog.
+IPC_MESSAGE_CONTROL1(PpapiHostMsg_PDF_ShowConfirmDialog,
+                     std::string /* message */)
+// Reply from the renderer with the results of the confirm dialog.
+IPC_MESSAGE_CONTROL1(PpapiPluginMsg_PDF_ShowConfirmDialogReply,
+                     bool /* bool result */)
+
+// Notifies the renderer to display a prompt dialog.
+IPC_MESSAGE_CONTROL2(PpapiHostMsg_PDF_ShowPromptDialog,
+                     std::string /* message */,
+                     std::string /* default answer */)
+// Reply from the renderer with the results of the prompt dialog.
+IPC_MESSAGE_CONTROL1(PpapiPluginMsg_PDF_ShowPromptDialogReply,
+                     std::string /* str_result */)
+
+// Notifies the renderer to save the current PDF.
+IPC_MESSAGE_CONTROL0(PpapiHostMsg_PDF_SaveAs)
+
+// Called by the plugin when its selection changes.
+IPC_MESSAGE_CONTROL1(PpapiHostMsg_PDF_SetSelectedText,
+                     std::u16string /* selected_text */)
+
+// Called by the plugin to set the link under the cursor.
+IPC_MESSAGE_CONTROL1(PpapiHostMsg_PDF_SetLinkUnderCursor,
+                     std::string /* url */)
+
+// Send information about the selection coordinates.
+IPC_MESSAGE_CONTROL4(PpapiHostMsg_PDF_SelectionChanged,
+                     PP_FloatPoint /* left */,
+                     int32_t /* left_height */,
+                     PP_FloatPoint /* right */,
+                     int32_t /* right_height */)
+
+// Lets the renderer know that the PDF plugin can handle save commands
+// internally. i.e. It will provide the data to save and trigger the download
+// dialog.
+IPC_MESSAGE_CONTROL1(PpapiHostMsg_PDF_SetPluginCanSave, bool /* can_save */)
+
 // VideoCapture ----------------------------------------------------------------
 
 // VideoCapture_Dev, plugin -> host
diff --git a/ppapi/tests/OWNERS b/ppapi/tests/OWNERS
index 17525ab89a2c3..107fb802bc9af 100644
--- a/ppapi/tests/OWNERS
+++ b/ppapi/tests/OWNERS
@@ -1,2 +1,3 @@
 per-file blink_test_plugin.cc=dcheng@chromium.org
 per-file blink_deprecated_test_plugin.cc=dcheng@chromium.org
+per-file test_pdf.*=thestig@chromium.org
diff --git a/ppapi/tests/test_pdf.cc b/ppapi/tests/test_pdf.cc
new file mode 100644
index 0000000000000..644cf26197b2f
--- /dev/null
+++ b/ppapi/tests/test_pdf.cc
@@ -0,0 +1,37 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ppapi/tests/test_pdf.h"
+
+#include "ppapi/c/private/ppb_pdf.h"
+#include "ppapi/cpp/image_data.h"
+#include "ppapi/cpp/point.h"
+#include "ppapi/cpp/private/pdf.h"
+#include "ppapi/cpp/var.h"
+#include "ppapi/tests/testing_instance.h"
+
+REGISTER_TEST_CASE(PDF);
+
+TestPDF::TestPDF(TestingInstance* instance)
+    : TestCase(instance) {
+}
+
+void TestPDF::RunTests(const std::string& filter) {
+  RUN_TEST(GetV8ExternalSnapshotData, filter);
+}
+
+std::string TestPDF::TestGetV8ExternalSnapshotData() {
+  const char* snapshot_data;
+  int snapshot_size;
+
+  pp::PDF::GetV8ExternalSnapshotData(instance_, &snapshot_data, &snapshot_size);
+#ifdef V8_USE_EXTERNAL_STARTUP_DATA
+  ASSERT_NE(snapshot_data, (char*) (NULL));
+  ASSERT_NE(snapshot_size, 0);
+#else
+  ASSERT_EQ(snapshot_data, (char*) (NULL));
+  ASSERT_EQ(snapshot_size, 0);
+#endif
+  PASS();
+}
diff --git a/ppapi/tests/test_pdf.h b/ppapi/tests/test_pdf.h
new file mode 100644
index 0000000000000..10effb9d5ed43
--- /dev/null
+++ b/ppapi/tests/test_pdf.h
@@ -0,0 +1,25 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef PPAPI_TESTS_TEST_PDF_H_
+#define PPAPI_TESTS_TEST_PDF_H_
+
+#include <string>
+
+#include "ppapi/c/pp_stdint.h"
+#include "ppapi/tests/test_case.h"
+
+class TestPDF : public TestCase {
+ public:
+  explicit TestPDF(TestingInstance* instance);
+
+  // TestCase implementation.
+  virtual void RunTests(const std::string& filter);
+
+ private:
+  std::string TestGetLocalizedString();
+  std::string TestGetV8ExternalSnapshotData();
+};
+
+#endif  // PPAPI_TESTS_TEST_PDF_H_
diff --git a/ppapi/thunk/ppb_pdf_api.h b/ppapi/thunk/ppb_pdf_api.h
index a19b85e3136c0..aeb033cd1b2bb 100644
--- a/ppapi/thunk/ppb_pdf_api.h
+++ b/ppapi/thunk/ppb_pdf_api.h
@@ -13,7 +13,33 @@ namespace thunk {
 
 class PPB_PDF_API {
  public:
+  virtual void SearchString(const unsigned short* input_string,
+                            const unsigned short* input_term,
+                            bool case_sensitive,
+                            PP_PrivateFindResult** results,
+                            uint32_t* count) = 0;
+  virtual void DidStartLoading() = 0;
+  virtual void DidStopLoading() = 0;
+  virtual void SetContentRestriction(int restrictions) = 0;
+  virtual void UserMetricsRecordAction(const PP_Var& action) = 0;
+  virtual void HasUnsupportedFeature() = 0;
+  virtual void ShowAlertDialog(const char* message) = 0;
+  virtual bool ShowConfirmDialog(const char* message) = 0;
+  virtual PP_Var ShowPromptDialog(const char* message,
+                                  const char* default_answer) = 0;
+  virtual void SaveAs() = 0;
+  virtual PP_Bool IsFeatureEnabled(PP_PDFFeature feature) = 0;
   virtual void Print() = 0;
+  virtual void SetSelectedText(const char* selected_text) = 0;
+  virtual void SetLinkUnderCursor(const char* url) = 0;
+  virtual void GetV8ExternalSnapshotData(const char** snapshot_data_out,
+                                         int* snapshot_size_out) = 0;
+  virtual void SetCrashData(const char* pdf_url, const char* top_level_url) = 0;
+  virtual void SelectionChanged(const PP_FloatPoint& left,
+                                int32_t left_height,
+                                const PP_FloatPoint& right,
+                                int32_t right_height) = 0;
+  virtual void SetPluginCanSave(bool can_save) = 0;
 
   static const SingletonResourceID kSingletonResourceID = PDF_SINGLETON_ID;
 };
diff --git a/ppapi/thunk/ppb_pdf_thunk.cc b/ppapi/thunk/ppb_pdf_thunk.cc
index 310e5191bddae..464a022d971c3 100644
--- a/ppapi/thunk/ppb_pdf_thunk.cc
+++ b/ppapi/thunk/ppb_pdf_thunk.cc
@@ -2,9 +2,14 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include <stdint.h>
+
+#include "ppapi/c/pp_errors.h"
 #include "ppapi/c/private/ppb_pdf.h"
 #include "ppapi/thunk/enter.h"
+#include "ppapi/thunk/ppb_flash_font_file_api.h"
 #include "ppapi/thunk/ppb_pdf_api.h"
+#include "ppapi/thunk/resource_creation_api.h"
 #include "ppapi/thunk/thunk.h"
 
 namespace ppapi {
@@ -12,14 +17,187 @@ namespace thunk {
 
 namespace {
 
+PP_Resource GetFontFileWithFallback(
+    PP_Instance instance,
+    const PP_BrowserFont_Trusted_Description* description,
+    PP_PrivateFontCharset charset) {
+  // TODO(raymes): Eventually we should replace the use of this function with
+  // PPB_Flash_Font_File directly in the PDF code.
+  // For now just call into PPB_Flash_Font_File which has the exact same API.
+  EnterResourceCreation enter(instance);
+  if (enter.failed())
+    return 0;
+  return enter.functions()->CreateFlashFontFile(instance, description, charset);
+}
+
+bool GetFontTableForPrivateFontFile(PP_Resource font_file,
+                                    uint32_t table,
+                                    void* output,
+                                    uint32_t* output_length) {
+  // TODO(raymes): Eventually we should replace the use of this function with
+  // PPB_Flash_Font_File directly in the PDF code.
+  // For now just call into PPB_Flash_Font_File which has the exact same API.
+  EnterResource<PPB_Flash_FontFile_API> enter(font_file, true);
+  if (enter.failed())
+    return PP_FALSE;
+  return PP_ToBool(enter.object()->GetFontTable(table, output, output_length));
+}
+
+void SearchString(PP_Instance instance,
+                  const unsigned short* string,
+                  const unsigned short* term,
+                  bool case_sensitive,
+                  PP_PrivateFindResult** results,
+                  uint32_t* count) {
+  EnterInstanceAPI<PPB_PDF_API> enter(instance);
+  if (enter.failed())
+    return;
+  enter.functions()->SearchString(string, term, case_sensitive, results, count);
+}
+
+void DidStartLoading(PP_Instance instance) {
+  EnterInstanceAPI<PPB_PDF_API> enter(instance);
+  if (enter.succeeded())
+    enter.functions()->DidStartLoading();
+}
+
+void DidStopLoading(PP_Instance instance) {
+  EnterInstanceAPI<PPB_PDF_API> enter(instance);
+  if (enter.succeeded())
+    enter.functions()->DidStopLoading();
+}
+
+void SetContentRestriction(PP_Instance instance, int restrictions) {
+  EnterInstanceAPI<PPB_PDF_API> enter(instance);
+  if (enter.succeeded())
+    enter.functions()->SetContentRestriction(restrictions);
+}
+
+void UserMetricsRecordAction(PP_Instance instance, PP_Var action) {
+  EnterInstanceAPI<PPB_PDF_API> enter(instance);
+  if (enter.succeeded())
+    enter.functions()->UserMetricsRecordAction(action);
+}
+
+void HasUnsupportedFeature(PP_Instance instance) {
+  EnterInstanceAPI<PPB_PDF_API> enter(instance);
+  if (enter.succeeded())
+    enter.functions()->HasUnsupportedFeature();
+}
+
+void ShowAlertDialog(PP_Instance instance, const char* message) {
+  EnterInstanceAPI<PPB_PDF_API> enter(instance);
+  if (enter.succeeded())
+    enter.functions()->ShowAlertDialog(message);
+}
+
+bool ShowConfirmDialog(PP_Instance instance, const char* message) {
+  EnterInstanceAPI<PPB_PDF_API> enter(instance);
+  if (enter.succeeded())
+    return enter.functions()->ShowConfirmDialog(message);
+  return false;
+}
+
+PP_Var ShowPromptDialog(PP_Instance instance,
+                        const char* message,
+                        const char* default_answer) {
+  EnterInstanceAPI<PPB_PDF_API> enter(instance);
+  if (enter.succeeded())
+    return enter.functions()->ShowPromptDialog(message, default_answer);
+  return PP_MakeUndefined();
+}
+
+void SaveAs(PP_Instance instance) {
+  EnterInstanceAPI<PPB_PDF_API> enter(instance);
+  if (enter.succeeded())
+    enter.functions()->SaveAs();
+}
+
 void Print(PP_Instance instance) {
   EnterInstanceAPI<PPB_PDF_API> enter(instance);
   if (enter.succeeded())
     enter.functions()->Print();
 }
 
+PP_Bool IsFeatureEnabled(PP_Instance instance, PP_PDFFeature feature) {
+  EnterInstanceAPI<PPB_PDF_API> enter(instance);
+  if (enter.failed())
+    return PP_FALSE;
+  return enter.functions()->IsFeatureEnabled(feature);
+}
+
+void SetSelectedText(PP_Instance instance,
+                     const char* selected_text) {
+  EnterInstanceAPI<PPB_PDF_API> enter(instance);
+  if (enter.succeeded())
+    enter.functions()->SetSelectedText(selected_text);
+}
+
+void SetLinkUnderCursor(PP_Instance instance, const char* url) {
+  EnterInstanceAPI<PPB_PDF_API> enter(instance);
+  if (enter.failed())
+    return;
+  enter.functions()->SetLinkUnderCursor(url);
+}
+
+void GetV8ExternalSnapshotData(PP_Instance instance,
+                               const char** snapshot_data_out,
+                               int* snapshot_size_out) {
+  EnterInstanceAPI<PPB_PDF_API> enter(instance);
+  if (enter.failed())
+    return;
+  enter.functions()->GetV8ExternalSnapshotData(snapshot_data_out,
+                                               snapshot_size_out);
+}
+
+void SetCrashData(PP_Instance instance,
+                  const char* pdf_url,
+                  const char* top_level_url) {
+  EnterInstanceAPI<PPB_PDF_API> enter(instance);
+  if (enter.failed())
+    return;
+  enter.functions()->SetCrashData(pdf_url, top_level_url);
+}
+
+void SelectionChanged(PP_Instance instance,
+                      const PP_FloatPoint* left,
+                      int32_t left_height,
+                      const PP_FloatPoint* right,
+                      int32_t right_height) {
+  EnterInstanceAPI<PPB_PDF_API> enter(instance);
+  if (enter.failed())
+    return;
+  enter.functions()->SelectionChanged(*left, left_height, *right, right_height);
+}
+
+void SetPluginCanSave(PP_Instance instance, bool can_save) {
+  EnterInstanceAPI<PPB_PDF_API> enter(instance);
+  if (enter.failed())
+    return;
+  enter.functions()->SetPluginCanSave(can_save);
+}
+
 const PPB_PDF g_ppb_pdf_thunk = {
+    &GetFontFileWithFallback,
+    &GetFontTableForPrivateFontFile,
+    &SearchString,
+    &DidStartLoading,
+    &DidStopLoading,
+    &SetContentRestriction,
+    &UserMetricsRecordAction,
+    &HasUnsupportedFeature,
+    &SaveAs,
     &Print,
+    &IsFeatureEnabled,
+    &SetSelectedText,
+    &SetLinkUnderCursor,
+    &GetV8ExternalSnapshotData,
+    &SetCrashData,
+    &SelectionChanged,
+    &SetPluginCanSave,
+    &ShowAlertDialog,
+    &ShowConfirmDialog,
+    &ShowPromptDialog,
 };
 
 }  // namespace
